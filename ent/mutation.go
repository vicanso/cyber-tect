// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/vicanso/cybertect/ent/configuration"
	"github.com/vicanso/cybertect/ent/databasedetector"
	"github.com/vicanso/cybertect/ent/databasedetectorresult"
	"github.com/vicanso/cybertect/ent/dnsdetector"
	"github.com/vicanso/cybertect/ent/dnsdetectorresult"
	"github.com/vicanso/cybertect/ent/httpdetector"
	"github.com/vicanso/cybertect/ent/httpdetectorresult"
	"github.com/vicanso/cybertect/ent/pingdetector"
	"github.com/vicanso/cybertect/ent/pingdetectorresult"
	"github.com/vicanso/cybertect/ent/predicate"
	"github.com/vicanso/cybertect/ent/tcpdetector"
	"github.com/vicanso/cybertect/ent/tcpdetectorresult"
	"github.com/vicanso/cybertect/ent/user"
	"github.com/vicanso/cybertect/ent/userlogin"
	"github.com/vicanso/cybertect/schema"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConfiguration          = "Configuration"
	TypeDNSDetector            = "DNSDetector"
	TypeDNSDetectorResult      = "DNSDetectorResult"
	TypeDatabaseDetector       = "DatabaseDetector"
	TypeDatabaseDetectorResult = "DatabaseDetectorResult"
	TypeHTTPDetector           = "HTTPDetector"
	TypeHTTPDetectorResult     = "HTTPDetectorResult"
	TypePingDetector           = "PingDetector"
	TypePingDetectorResult     = "PingDetectorResult"
	TypeTCPDetector            = "TCPDetector"
	TypeTCPDetectorResult      = "TCPDetectorResult"
	TypeUser                   = "User"
	TypeUserLogin              = "UserLogin"
)

// ConfigurationMutation represents an operation that mutates the Configuration nodes in the graph.
type ConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	category      *configuration.Category
	owner         *string
	data          *string
	started_at    *time.Time
	ended_at      *time.Time
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Configuration, error)
	predicates    []predicate.Configuration
}

var _ ent.Mutation = (*ConfigurationMutation)(nil)

// configurationOption allows management of the mutation configuration using functional options.
type configurationOption func(*ConfigurationMutation)

// newConfigurationMutation creates new mutation for the Configuration entity.
func newConfigurationMutation(c config, op Op, opts ...configurationOption) *ConfigurationMutation {
	m := &ConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationID sets the ID field of the mutation.
func withConfigurationID(id int) configurationOption {
	return func(m *ConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configuration
		)
		m.oldValue = func(ctx context.Context) (*Configuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfiguration sets the old Configuration of the mutation.
func withConfiguration(node *Configuration) configurationOption {
	return func(m *ConfigurationMutation) {
		m.oldValue = func(context.Context) (*Configuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Configuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ConfigurationMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ConfigurationMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *ConfigurationMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ConfigurationMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ConfigurationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *ConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *ConfigurationMutation) SetCategory(c configuration.Category) {
	m.category = &c
}

// Category returns the value of the "category" field in the mutation.
func (m *ConfigurationMutation) Category() (r configuration.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCategory(ctx context.Context) (v configuration.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConfigurationMutation) ResetCategory() {
	m.category = nil
}

// SetOwner sets the "owner" field.
func (m *ConfigurationMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *ConfigurationMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *ConfigurationMutation) ResetOwner() {
	m.owner = nil
}

// SetData sets the "data" field.
func (m *ConfigurationMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *ConfigurationMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *ConfigurationMutation) ResetData() {
	m.data = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ConfigurationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ConfigurationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ConfigurationMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *ConfigurationMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *ConfigurationMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *ConfigurationMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetDescription sets the "description" field.
func (m *ConfigurationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigurationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigurationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configuration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigurationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configuration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigurationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configuration.FieldDescription)
}

// Where appends a list predicates to the ConfigurationMutation builder.
func (m *ConfigurationMutation) Where(ps ...predicate.Configuration) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConfigurationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configuration).
func (m *ConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, configuration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configuration.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, configuration.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, configuration.FieldName)
	}
	if m.category != nil {
		fields = append(fields, configuration.FieldCategory)
	}
	if m.owner != nil {
		fields = append(fields, configuration.FieldOwner)
	}
	if m.data != nil {
		fields = append(fields, configuration.FieldData)
	}
	if m.started_at != nil {
		fields = append(fields, configuration.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, configuration.FieldEndedAt)
	}
	if m.description != nil {
		fields = append(fields, configuration.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.CreatedAt()
	case configuration.FieldUpdatedAt:
		return m.UpdatedAt()
	case configuration.FieldStatus:
		return m.Status()
	case configuration.FieldName:
		return m.Name()
	case configuration.FieldCategory:
		return m.Category()
	case configuration.FieldOwner:
		return m.Owner()
	case configuration.FieldData:
		return m.Data()
	case configuration.FieldStartedAt:
		return m.StartedAt()
	case configuration.FieldEndedAt:
		return m.EndedAt()
	case configuration.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configuration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case configuration.FieldStatus:
		return m.OldStatus(ctx)
	case configuration.FieldName:
		return m.OldName(ctx)
	case configuration.FieldCategory:
		return m.OldCategory(ctx)
	case configuration.FieldOwner:
		return m.OldOwner(ctx)
	case configuration.FieldData:
		return m.OldData(ctx)
	case configuration.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case configuration.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case configuration.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Configuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configuration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case configuration.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case configuration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configuration.FieldCategory:
		v, ok := value.(configuration.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case configuration.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case configuration.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case configuration.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case configuration.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case configuration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, configuration.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configuration.FieldDescription) {
		fields = append(fields, configuration.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationMutation) ClearField(name string) error {
	switch name {
	case configuration.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Configuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationMutation) ResetField(name string) error {
	switch name {
	case configuration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configuration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case configuration.FieldStatus:
		m.ResetStatus()
		return nil
	case configuration.FieldName:
		m.ResetName()
		return nil
	case configuration.FieldCategory:
		m.ResetCategory()
		return nil
	case configuration.FieldOwner:
		m.ResetOwner()
		return nil
	case configuration.FieldData:
		m.ResetData()
		return nil
	case configuration.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case configuration.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case configuration.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configuration edge %s", name)
}

// DNSDetectorMutation represents an operation that mutates the DNSDetector nodes in the graph.
type DNSDetectorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	status          *schema.Status
	addstatus       *schema.Status
	name            *string
	owners          *[]string
	appendowners    []string
	receivers       *[]string
	appendreceivers []string
	timeout         *string
	interval        *string
	description     *string
	host            *string
	ips             *[]string
	appendips       []string
	servers         *[]string
	appendservers   []string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*DNSDetector, error)
	predicates      []predicate.DNSDetector
}

var _ ent.Mutation = (*DNSDetectorMutation)(nil)

// dnsdetectorOption allows management of the mutation configuration using functional options.
type dnsdetectorOption func(*DNSDetectorMutation)

// newDNSDetectorMutation creates new mutation for the DNSDetector entity.
func newDNSDetectorMutation(c config, op Op, opts ...dnsdetectorOption) *DNSDetectorMutation {
	m := &DNSDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSDetectorID sets the ID field of the mutation.
func withDNSDetectorID(id int) dnsdetectorOption {
	return func(m *DNSDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSDetector
		)
		m.oldValue = func(ctx context.Context) (*DNSDetector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSDetector sets the old DNSDetector of the mutation.
func withDNSDetector(node *DNSDetector) dnsdetectorOption {
	return func(m *DNSDetectorMutation) {
		m.oldValue = func(context.Context) (*DNSDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSDetectorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSDetector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DNSDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DNSDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DNSDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DNSDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DNSDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DNSDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DNSDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DNSDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *DNSDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DNSDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DNSDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *DNSDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwners sets the "owners" field.
func (m *DNSDetectorMutation) SetOwners(s []string) {
	m.owners = &s
	m.appendowners = nil
}

// Owners returns the value of the "owners" field in the mutation.
func (m *DNSDetectorMutation) Owners() (r []string, exists bool) {
	v := m.owners
	if v == nil {
		return
	}
	return *v, true
}

// OldOwners returns the old "owners" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldOwners(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwners: %w", err)
	}
	return oldValue.Owners, nil
}

// AppendOwners adds s to the "owners" field.
func (m *DNSDetectorMutation) AppendOwners(s []string) {
	m.appendowners = append(m.appendowners, s...)
}

// AppendedOwners returns the list of values that were appended to the "owners" field in this mutation.
func (m *DNSDetectorMutation) AppendedOwners() ([]string, bool) {
	if len(m.appendowners) == 0 {
		return nil, false
	}
	return m.appendowners, true
}

// ResetOwners resets all changes to the "owners" field.
func (m *DNSDetectorMutation) ResetOwners() {
	m.owners = nil
	m.appendowners = nil
}

// SetReceivers sets the "receivers" field.
func (m *DNSDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *DNSDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds s to the "receivers" field.
func (m *DNSDetectorMutation) AppendReceivers(s []string) {
	m.appendreceivers = append(m.appendreceivers, s...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *DNSDetectorMutation) AppendedReceivers() ([]string, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *DNSDetectorMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *DNSDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *DNSDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *DNSDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetInterval sets the "interval" field.
func (m *DNSDetectorMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *DNSDetectorMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ClearInterval clears the value of the "interval" field.
func (m *DNSDetectorMutation) ClearInterval() {
	m.interval = nil
	m.clearedFields[dnsdetector.FieldInterval] = struct{}{}
}

// IntervalCleared returns if the "interval" field was cleared in this mutation.
func (m *DNSDetectorMutation) IntervalCleared() bool {
	_, ok := m.clearedFields[dnsdetector.FieldInterval]
	return ok
}

// ResetInterval resets all changes to the "interval" field.
func (m *DNSDetectorMutation) ResetInterval() {
	m.interval = nil
	delete(m.clearedFields, dnsdetector.FieldInterval)
}

// SetDescription sets the "description" field.
func (m *DNSDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DNSDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DNSDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetHost sets the "host" field.
func (m *DNSDetectorMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *DNSDetectorMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *DNSDetectorMutation) ResetHost() {
	m.host = nil
}

// SetIps sets the "ips" field.
func (m *DNSDetectorMutation) SetIps(s []string) {
	m.ips = &s
	m.appendips = nil
}

// Ips returns the value of the "ips" field in the mutation.
func (m *DNSDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// AppendIps adds s to the "ips" field.
func (m *DNSDetectorMutation) AppendIps(s []string) {
	m.appendips = append(m.appendips, s...)
}

// AppendedIps returns the list of values that were appended to the "ips" field in this mutation.
func (m *DNSDetectorMutation) AppendedIps() ([]string, bool) {
	if len(m.appendips) == 0 {
		return nil, false
	}
	return m.appendips, true
}

// ResetIps resets all changes to the "ips" field.
func (m *DNSDetectorMutation) ResetIps() {
	m.ips = nil
	m.appendips = nil
}

// SetServers sets the "servers" field.
func (m *DNSDetectorMutation) SetServers(s []string) {
	m.servers = &s
	m.appendservers = nil
}

// Servers returns the value of the "servers" field in the mutation.
func (m *DNSDetectorMutation) Servers() (r []string, exists bool) {
	v := m.servers
	if v == nil {
		return
	}
	return *v, true
}

// OldServers returns the old "servers" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServers: %w", err)
	}
	return oldValue.Servers, nil
}

// AppendServers adds s to the "servers" field.
func (m *DNSDetectorMutation) AppendServers(s []string) {
	m.appendservers = append(m.appendservers, s...)
}

// AppendedServers returns the list of values that were appended to the "servers" field in this mutation.
func (m *DNSDetectorMutation) AppendedServers() ([]string, bool) {
	if len(m.appendservers) == 0 {
		return nil, false
	}
	return m.appendservers, true
}

// ResetServers resets all changes to the "servers" field.
func (m *DNSDetectorMutation) ResetServers() {
	m.servers = nil
	m.appendservers = nil
}

// Where appends a list predicates to the DNSDetectorMutation builder.
func (m *DNSDetectorMutation) Where(ps ...predicate.DNSDetector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DNSDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSDetector).
func (m *DNSDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSDetectorMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, dnsdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dnsdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, dnsdetector.FieldName)
	}
	if m.owners != nil {
		fields = append(fields, dnsdetector.FieldOwners)
	}
	if m.receivers != nil {
		fields = append(fields, dnsdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, dnsdetector.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, dnsdetector.FieldInterval)
	}
	if m.description != nil {
		fields = append(fields, dnsdetector.FieldDescription)
	}
	if m.host != nil {
		fields = append(fields, dnsdetector.FieldHost)
	}
	if m.ips != nil {
		fields = append(fields, dnsdetector.FieldIps)
	}
	if m.servers != nil {
		fields = append(fields, dnsdetector.FieldServers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsdetector.FieldCreatedAt:
		return m.CreatedAt()
	case dnsdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsdetector.FieldStatus:
		return m.Status()
	case dnsdetector.FieldName:
		return m.Name()
	case dnsdetector.FieldOwners:
		return m.Owners()
	case dnsdetector.FieldReceivers:
		return m.Receivers()
	case dnsdetector.FieldTimeout:
		return m.Timeout()
	case dnsdetector.FieldInterval:
		return m.Interval()
	case dnsdetector.FieldDescription:
		return m.Description()
	case dnsdetector.FieldHost:
		return m.Host()
	case dnsdetector.FieldIps:
		return m.Ips()
	case dnsdetector.FieldServers:
		return m.Servers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsdetector.FieldStatus:
		return m.OldStatus(ctx)
	case dnsdetector.FieldName:
		return m.OldName(ctx)
	case dnsdetector.FieldOwners:
		return m.OldOwners(ctx)
	case dnsdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case dnsdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case dnsdetector.FieldInterval:
		return m.OldInterval(ctx)
	case dnsdetector.FieldDescription:
		return m.OldDescription(ctx)
	case dnsdetector.FieldHost:
		return m.OldHost(ctx)
	case dnsdetector.FieldIps:
		return m.OldIps(ctx)
	case dnsdetector.FieldServers:
		return m.OldServers(ctx)
	}
	return nil, fmt.Errorf("unknown DNSDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dnsdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsdetector.FieldOwners:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwners(v)
		return nil
	case dnsdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case dnsdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case dnsdetector.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case dnsdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dnsdetector.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case dnsdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case dnsdetector.FieldServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServers(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dnsdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSDetectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dnsdetector.FieldInterval) {
		fields = append(fields, dnsdetector.FieldInterval)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSDetectorMutation) ClearField(name string) error {
	switch name {
	case dnsdetector.FieldInterval:
		m.ClearInterval()
		return nil
	}
	return fmt.Errorf("unknown DNSDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSDetectorMutation) ResetField(name string) error {
	switch name {
	case dnsdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case dnsdetector.FieldName:
		m.ResetName()
		return nil
	case dnsdetector.FieldOwners:
		m.ResetOwners()
		return nil
	case dnsdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case dnsdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case dnsdetector.FieldInterval:
		m.ResetInterval()
		return nil
	case dnsdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case dnsdetector.FieldHost:
		m.ResetHost()
		return nil
	case dnsdetector.FieldIps:
		m.ResetIps()
		return nil
	case dnsdetector.FieldServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown DNSDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNSDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNSDetector edge %s", name)
}

// DNSDetectorResultMutation represents an operation that mutates the DNSDetectorResult nodes in the graph.
type DNSDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *schema.DetectorResult
	addresult      *schema.DetectorResult
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	appendmessages []string
	host           *string
	results        *schema.DNSDetectorSubResults
	appendresults  schema.DNSDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DNSDetectorResult, error)
	predicates     []predicate.DNSDetectorResult
}

var _ ent.Mutation = (*DNSDetectorResultMutation)(nil)

// dnsdetectorresultOption allows management of the mutation configuration using functional options.
type dnsdetectorresultOption func(*DNSDetectorResultMutation)

// newDNSDetectorResultMutation creates new mutation for the DNSDetectorResult entity.
func newDNSDetectorResultMutation(c config, op Op, opts ...dnsdetectorresultOption) *DNSDetectorResultMutation {
	m := &DNSDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSDetectorResultID sets the ID field of the mutation.
func withDNSDetectorResultID(id int) dnsdetectorresultOption {
	return func(m *DNSDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*DNSDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSDetectorResult sets the old DNSDetectorResult of the mutation.
func withDNSDetectorResult(node *DNSDetectorResult) dnsdetectorresultOption {
	return func(m *DNSDetectorResultMutation) {
		m.oldValue = func(context.Context) (*DNSDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSDetectorResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSDetectorResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DNSDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DNSDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DNSDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DNSDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DNSDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DNSDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *DNSDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *DNSDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *DNSDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *DNSDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *DNSDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *DNSDetectorResultMutation) SetResult(sr schema.DetectorResult) {
	m.result = &sr
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *DNSDetectorResultMutation) Result() (r schema.DetectorResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldResult(ctx context.Context) (v schema.DetectorResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds sr to the "result" field.
func (m *DNSDetectorResultMutation) AddResult(sr schema.DetectorResult) {
	if m.addresult != nil {
		*m.addresult += sr
	} else {
		m.addresult = &sr
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *DNSDetectorResultMutation) AddedResult() (r schema.DetectorResult, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *DNSDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *DNSDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *DNSDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *DNSDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *DNSDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *DNSDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *DNSDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *DNSDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *DNSDetectorResultMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *DNSDetectorResultMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ResetMessages resets all changes to the "messages" field.
func (m *DNSDetectorResultMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
}

// SetHost sets the "host" field.
func (m *DNSDetectorResultMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *DNSDetectorResultMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *DNSDetectorResultMutation) ResetHost() {
	m.host = nil
}

// SetResults sets the "results" field.
func (m *DNSDetectorResultMutation) SetResults(sdsr schema.DNSDetectorSubResults) {
	m.results = &sdsr
	m.appendresults = nil
}

// Results returns the value of the "results" field in the mutation.
func (m *DNSDetectorResultMutation) Results() (r schema.DNSDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldResults(ctx context.Context) (v schema.DNSDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// AppendResults adds sdsr to the "results" field.
func (m *DNSDetectorResultMutation) AppendResults(sdsr schema.DNSDetectorSubResults) {
	m.appendresults = append(m.appendresults, sdsr...)
}

// AppendedResults returns the list of values that were appended to the "results" field in this mutation.
func (m *DNSDetectorResultMutation) AppendedResults() (schema.DNSDetectorSubResults, bool) {
	if len(m.appendresults) == 0 {
		return nil, false
	}
	return m.appendresults, true
}

// ResetResults resets all changes to the "results" field.
func (m *DNSDetectorResultMutation) ResetResults() {
	m.results = nil
	m.appendresults = nil
}

// Where appends a list predicates to the DNSDetectorResultMutation builder.
func (m *DNSDetectorResultMutation) Where(ps ...predicate.DNSDetectorResult) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DNSDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSDetectorResult).
func (m *DNSDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dnsdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, dnsdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, dnsdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, dnsdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, dnsdetectorresult.FieldMessages)
	}
	if m.host != nil {
		fields = append(fields, dnsdetectorresult.FieldHost)
	}
	if m.results != nil {
		fields = append(fields, dnsdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case dnsdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsdetectorresult.FieldTask:
		return m.Task()
	case dnsdetectorresult.FieldResult:
		return m.Result()
	case dnsdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case dnsdetectorresult.FieldMessages:
		return m.Messages()
	case dnsdetectorresult.FieldHost:
		return m.Host()
	case dnsdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case dnsdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case dnsdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case dnsdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case dnsdetectorresult.FieldHost:
		return m.OldHost(ctx)
	case dnsdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case dnsdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case dnsdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case dnsdetectorresult.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case dnsdetectorresult.FieldResults:
		v, ok := value.(schema.DNSDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, dnsdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, dnsdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, dnsdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsdetectorresult.FieldTask:
		return m.AddedTask()
	case dnsdetectorresult.FieldResult:
		return m.AddedResult()
	case dnsdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case dnsdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSDetectorResultMutation) ResetField(name string) error {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case dnsdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case dnsdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case dnsdetectorresult.FieldHost:
		m.ResetHost()
		return nil
	case dnsdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult edge %s", name)
}

// DatabaseDetectorMutation represents an operation that mutates the DatabaseDetector nodes in the graph.
type DatabaseDetectorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	status          *schema.Status
	addstatus       *schema.Status
	name            *string
	owners          *[]string
	appendowners    []string
	receivers       *[]string
	appendreceivers []string
	timeout         *string
	interval        *string
	description     *string
	uris            *[]string
	appenduris      []string
	certPem         *string
	keyPem          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*DatabaseDetector, error)
	predicates      []predicate.DatabaseDetector
}

var _ ent.Mutation = (*DatabaseDetectorMutation)(nil)

// databasedetectorOption allows management of the mutation configuration using functional options.
type databasedetectorOption func(*DatabaseDetectorMutation)

// newDatabaseDetectorMutation creates new mutation for the DatabaseDetector entity.
func newDatabaseDetectorMutation(c config, op Op, opts ...databasedetectorOption) *DatabaseDetectorMutation {
	m := &DatabaseDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeDatabaseDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDatabaseDetectorID sets the ID field of the mutation.
func withDatabaseDetectorID(id int) databasedetectorOption {
	return func(m *DatabaseDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *DatabaseDetector
		)
		m.oldValue = func(ctx context.Context) (*DatabaseDetector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DatabaseDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDatabaseDetector sets the old DatabaseDetector of the mutation.
func withDatabaseDetector(node *DatabaseDetector) databasedetectorOption {
	return func(m *DatabaseDetectorMutation) {
		m.oldValue = func(context.Context) (*DatabaseDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DatabaseDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DatabaseDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DatabaseDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DatabaseDetectorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DatabaseDetector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DatabaseDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DatabaseDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DatabaseDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DatabaseDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DatabaseDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DatabaseDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DatabaseDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DatabaseDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *DatabaseDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DatabaseDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DatabaseDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *DatabaseDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DatabaseDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DatabaseDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwners sets the "owners" field.
func (m *DatabaseDetectorMutation) SetOwners(s []string) {
	m.owners = &s
	m.appendowners = nil
}

// Owners returns the value of the "owners" field in the mutation.
func (m *DatabaseDetectorMutation) Owners() (r []string, exists bool) {
	v := m.owners
	if v == nil {
		return
	}
	return *v, true
}

// OldOwners returns the old "owners" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldOwners(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwners: %w", err)
	}
	return oldValue.Owners, nil
}

// AppendOwners adds s to the "owners" field.
func (m *DatabaseDetectorMutation) AppendOwners(s []string) {
	m.appendowners = append(m.appendowners, s...)
}

// AppendedOwners returns the list of values that were appended to the "owners" field in this mutation.
func (m *DatabaseDetectorMutation) AppendedOwners() ([]string, bool) {
	if len(m.appendowners) == 0 {
		return nil, false
	}
	return m.appendowners, true
}

// ResetOwners resets all changes to the "owners" field.
func (m *DatabaseDetectorMutation) ResetOwners() {
	m.owners = nil
	m.appendowners = nil
}

// SetReceivers sets the "receivers" field.
func (m *DatabaseDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *DatabaseDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds s to the "receivers" field.
func (m *DatabaseDetectorMutation) AppendReceivers(s []string) {
	m.appendreceivers = append(m.appendreceivers, s...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *DatabaseDetectorMutation) AppendedReceivers() ([]string, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *DatabaseDetectorMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *DatabaseDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *DatabaseDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *DatabaseDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetInterval sets the "interval" field.
func (m *DatabaseDetectorMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *DatabaseDetectorMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ClearInterval clears the value of the "interval" field.
func (m *DatabaseDetectorMutation) ClearInterval() {
	m.interval = nil
	m.clearedFields[databasedetector.FieldInterval] = struct{}{}
}

// IntervalCleared returns if the "interval" field was cleared in this mutation.
func (m *DatabaseDetectorMutation) IntervalCleared() bool {
	_, ok := m.clearedFields[databasedetector.FieldInterval]
	return ok
}

// ResetInterval resets all changes to the "interval" field.
func (m *DatabaseDetectorMutation) ResetInterval() {
	m.interval = nil
	delete(m.clearedFields, databasedetector.FieldInterval)
}

// SetDescription sets the "description" field.
func (m *DatabaseDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DatabaseDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DatabaseDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetUris sets the "uris" field.
func (m *DatabaseDetectorMutation) SetUris(s []string) {
	m.uris = &s
	m.appenduris = nil
}

// Uris returns the value of the "uris" field in the mutation.
func (m *DatabaseDetectorMutation) Uris() (r []string, exists bool) {
	v := m.uris
	if v == nil {
		return
	}
	return *v, true
}

// OldUris returns the old "uris" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUris: %w", err)
	}
	return oldValue.Uris, nil
}

// AppendUris adds s to the "uris" field.
func (m *DatabaseDetectorMutation) AppendUris(s []string) {
	m.appenduris = append(m.appenduris, s...)
}

// AppendedUris returns the list of values that were appended to the "uris" field in this mutation.
func (m *DatabaseDetectorMutation) AppendedUris() ([]string, bool) {
	if len(m.appenduris) == 0 {
		return nil, false
	}
	return m.appenduris, true
}

// ResetUris resets all changes to the "uris" field.
func (m *DatabaseDetectorMutation) ResetUris() {
	m.uris = nil
	m.appenduris = nil
}

// SetCertPem sets the "certPem" field.
func (m *DatabaseDetectorMutation) SetCertPem(s string) {
	m.certPem = &s
}

// CertPem returns the value of the "certPem" field in the mutation.
func (m *DatabaseDetectorMutation) CertPem() (r string, exists bool) {
	v := m.certPem
	if v == nil {
		return
	}
	return *v, true
}

// OldCertPem returns the old "certPem" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldCertPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertPem: %w", err)
	}
	return oldValue.CertPem, nil
}

// ClearCertPem clears the value of the "certPem" field.
func (m *DatabaseDetectorMutation) ClearCertPem() {
	m.certPem = nil
	m.clearedFields[databasedetector.FieldCertPem] = struct{}{}
}

// CertPemCleared returns if the "certPem" field was cleared in this mutation.
func (m *DatabaseDetectorMutation) CertPemCleared() bool {
	_, ok := m.clearedFields[databasedetector.FieldCertPem]
	return ok
}

// ResetCertPem resets all changes to the "certPem" field.
func (m *DatabaseDetectorMutation) ResetCertPem() {
	m.certPem = nil
	delete(m.clearedFields, databasedetector.FieldCertPem)
}

// SetKeyPem sets the "keyPem" field.
func (m *DatabaseDetectorMutation) SetKeyPem(s string) {
	m.keyPem = &s
}

// KeyPem returns the value of the "keyPem" field in the mutation.
func (m *DatabaseDetectorMutation) KeyPem() (r string, exists bool) {
	v := m.keyPem
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPem returns the old "keyPem" field's value of the DatabaseDetector entity.
// If the DatabaseDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorMutation) OldKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPem: %w", err)
	}
	return oldValue.KeyPem, nil
}

// ClearKeyPem clears the value of the "keyPem" field.
func (m *DatabaseDetectorMutation) ClearKeyPem() {
	m.keyPem = nil
	m.clearedFields[databasedetector.FieldKeyPem] = struct{}{}
}

// KeyPemCleared returns if the "keyPem" field was cleared in this mutation.
func (m *DatabaseDetectorMutation) KeyPemCleared() bool {
	_, ok := m.clearedFields[databasedetector.FieldKeyPem]
	return ok
}

// ResetKeyPem resets all changes to the "keyPem" field.
func (m *DatabaseDetectorMutation) ResetKeyPem() {
	m.keyPem = nil
	delete(m.clearedFields, databasedetector.FieldKeyPem)
}

// Where appends a list predicates to the DatabaseDetectorMutation builder.
func (m *DatabaseDetectorMutation) Where(ps ...predicate.DatabaseDetector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DatabaseDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DatabaseDetector).
func (m *DatabaseDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DatabaseDetectorMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, databasedetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, databasedetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, databasedetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, databasedetector.FieldName)
	}
	if m.owners != nil {
		fields = append(fields, databasedetector.FieldOwners)
	}
	if m.receivers != nil {
		fields = append(fields, databasedetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, databasedetector.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, databasedetector.FieldInterval)
	}
	if m.description != nil {
		fields = append(fields, databasedetector.FieldDescription)
	}
	if m.uris != nil {
		fields = append(fields, databasedetector.FieldUris)
	}
	if m.certPem != nil {
		fields = append(fields, databasedetector.FieldCertPem)
	}
	if m.keyPem != nil {
		fields = append(fields, databasedetector.FieldKeyPem)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DatabaseDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case databasedetector.FieldCreatedAt:
		return m.CreatedAt()
	case databasedetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case databasedetector.FieldStatus:
		return m.Status()
	case databasedetector.FieldName:
		return m.Name()
	case databasedetector.FieldOwners:
		return m.Owners()
	case databasedetector.FieldReceivers:
		return m.Receivers()
	case databasedetector.FieldTimeout:
		return m.Timeout()
	case databasedetector.FieldInterval:
		return m.Interval()
	case databasedetector.FieldDescription:
		return m.Description()
	case databasedetector.FieldUris:
		return m.Uris()
	case databasedetector.FieldCertPem:
		return m.CertPem()
	case databasedetector.FieldKeyPem:
		return m.KeyPem()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DatabaseDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case databasedetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case databasedetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case databasedetector.FieldStatus:
		return m.OldStatus(ctx)
	case databasedetector.FieldName:
		return m.OldName(ctx)
	case databasedetector.FieldOwners:
		return m.OldOwners(ctx)
	case databasedetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case databasedetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case databasedetector.FieldInterval:
		return m.OldInterval(ctx)
	case databasedetector.FieldDescription:
		return m.OldDescription(ctx)
	case databasedetector.FieldUris:
		return m.OldUris(ctx)
	case databasedetector.FieldCertPem:
		return m.OldCertPem(ctx)
	case databasedetector.FieldKeyPem:
		return m.OldKeyPem(ctx)
	}
	return nil, fmt.Errorf("unknown DatabaseDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DatabaseDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case databasedetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case databasedetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case databasedetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case databasedetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case databasedetector.FieldOwners:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwners(v)
		return nil
	case databasedetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case databasedetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case databasedetector.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case databasedetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case databasedetector.FieldUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUris(v)
		return nil
	case databasedetector.FieldCertPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertPem(v)
		return nil
	case databasedetector.FieldKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPem(v)
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DatabaseDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, databasedetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DatabaseDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case databasedetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DatabaseDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case databasedetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DatabaseDetectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(databasedetector.FieldInterval) {
		fields = append(fields, databasedetector.FieldInterval)
	}
	if m.FieldCleared(databasedetector.FieldCertPem) {
		fields = append(fields, databasedetector.FieldCertPem)
	}
	if m.FieldCleared(databasedetector.FieldKeyPem) {
		fields = append(fields, databasedetector.FieldKeyPem)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DatabaseDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DatabaseDetectorMutation) ClearField(name string) error {
	switch name {
	case databasedetector.FieldInterval:
		m.ClearInterval()
		return nil
	case databasedetector.FieldCertPem:
		m.ClearCertPem()
		return nil
	case databasedetector.FieldKeyPem:
		m.ClearKeyPem()
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DatabaseDetectorMutation) ResetField(name string) error {
	switch name {
	case databasedetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case databasedetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case databasedetector.FieldStatus:
		m.ResetStatus()
		return nil
	case databasedetector.FieldName:
		m.ResetName()
		return nil
	case databasedetector.FieldOwners:
		m.ResetOwners()
		return nil
	case databasedetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case databasedetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case databasedetector.FieldInterval:
		m.ResetInterval()
		return nil
	case databasedetector.FieldDescription:
		m.ResetDescription()
		return nil
	case databasedetector.FieldUris:
		m.ResetUris()
		return nil
	case databasedetector.FieldCertPem:
		m.ResetCertPem()
		return nil
	case databasedetector.FieldKeyPem:
		m.ResetKeyPem()
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DatabaseDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DatabaseDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DatabaseDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DatabaseDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DatabaseDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DatabaseDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DatabaseDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DatabaseDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DatabaseDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DatabaseDetector edge %s", name)
}

// DatabaseDetectorResultMutation represents an operation that mutates the DatabaseDetectorResult nodes in the graph.
type DatabaseDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *schema.DetectorResult
	addresult      *schema.DetectorResult
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	appendmessages []string
	uris           *[]string
	appenduris     []string
	results        *schema.DatabaseDetectorSubResults
	appendresults  schema.DatabaseDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DatabaseDetectorResult, error)
	predicates     []predicate.DatabaseDetectorResult
}

var _ ent.Mutation = (*DatabaseDetectorResultMutation)(nil)

// databasedetectorresultOption allows management of the mutation configuration using functional options.
type databasedetectorresultOption func(*DatabaseDetectorResultMutation)

// newDatabaseDetectorResultMutation creates new mutation for the DatabaseDetectorResult entity.
func newDatabaseDetectorResultMutation(c config, op Op, opts ...databasedetectorresultOption) *DatabaseDetectorResultMutation {
	m := &DatabaseDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDatabaseDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDatabaseDetectorResultID sets the ID field of the mutation.
func withDatabaseDetectorResultID(id int) databasedetectorresultOption {
	return func(m *DatabaseDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DatabaseDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*DatabaseDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DatabaseDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDatabaseDetectorResult sets the old DatabaseDetectorResult of the mutation.
func withDatabaseDetectorResult(node *DatabaseDetectorResult) databasedetectorresultOption {
	return func(m *DatabaseDetectorResultMutation) {
		m.oldValue = func(context.Context) (*DatabaseDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DatabaseDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DatabaseDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DatabaseDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DatabaseDetectorResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DatabaseDetectorResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DatabaseDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DatabaseDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DatabaseDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DatabaseDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DatabaseDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DatabaseDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *DatabaseDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *DatabaseDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *DatabaseDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *DatabaseDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *DatabaseDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *DatabaseDetectorResultMutation) SetResult(sr schema.DetectorResult) {
	m.result = &sr
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *DatabaseDetectorResultMutation) Result() (r schema.DetectorResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldResult(ctx context.Context) (v schema.DetectorResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds sr to the "result" field.
func (m *DatabaseDetectorResultMutation) AddResult(sr schema.DetectorResult) {
	if m.addresult != nil {
		*m.addresult += sr
	} else {
		m.addresult = &sr
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *DatabaseDetectorResultMutation) AddedResult() (r schema.DetectorResult, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *DatabaseDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *DatabaseDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *DatabaseDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *DatabaseDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *DatabaseDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *DatabaseDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *DatabaseDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *DatabaseDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *DatabaseDetectorResultMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *DatabaseDetectorResultMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ResetMessages resets all changes to the "messages" field.
func (m *DatabaseDetectorResultMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
}

// SetUris sets the "uris" field.
func (m *DatabaseDetectorResultMutation) SetUris(s []string) {
	m.uris = &s
	m.appenduris = nil
}

// Uris returns the value of the "uris" field in the mutation.
func (m *DatabaseDetectorResultMutation) Uris() (r []string, exists bool) {
	v := m.uris
	if v == nil {
		return
	}
	return *v, true
}

// OldUris returns the old "uris" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUris: %w", err)
	}
	return oldValue.Uris, nil
}

// AppendUris adds s to the "uris" field.
func (m *DatabaseDetectorResultMutation) AppendUris(s []string) {
	m.appenduris = append(m.appenduris, s...)
}

// AppendedUris returns the list of values that were appended to the "uris" field in this mutation.
func (m *DatabaseDetectorResultMutation) AppendedUris() ([]string, bool) {
	if len(m.appenduris) == 0 {
		return nil, false
	}
	return m.appenduris, true
}

// ResetUris resets all changes to the "uris" field.
func (m *DatabaseDetectorResultMutation) ResetUris() {
	m.uris = nil
	m.appenduris = nil
}

// SetResults sets the "results" field.
func (m *DatabaseDetectorResultMutation) SetResults(sdsr schema.DatabaseDetectorSubResults) {
	m.results = &sdsr
	m.appendresults = nil
}

// Results returns the value of the "results" field in the mutation.
func (m *DatabaseDetectorResultMutation) Results() (r schema.DatabaseDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the DatabaseDetectorResult entity.
// If the DatabaseDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DatabaseDetectorResultMutation) OldResults(ctx context.Context) (v schema.DatabaseDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// AppendResults adds sdsr to the "results" field.
func (m *DatabaseDetectorResultMutation) AppendResults(sdsr schema.DatabaseDetectorSubResults) {
	m.appendresults = append(m.appendresults, sdsr...)
}

// AppendedResults returns the list of values that were appended to the "results" field in this mutation.
func (m *DatabaseDetectorResultMutation) AppendedResults() (schema.DatabaseDetectorSubResults, bool) {
	if len(m.appendresults) == 0 {
		return nil, false
	}
	return m.appendresults, true
}

// ResetResults resets all changes to the "results" field.
func (m *DatabaseDetectorResultMutation) ResetResults() {
	m.results = nil
	m.appendresults = nil
}

// Where appends a list predicates to the DatabaseDetectorResultMutation builder.
func (m *DatabaseDetectorResultMutation) Where(ps ...predicate.DatabaseDetectorResult) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DatabaseDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DatabaseDetectorResult).
func (m *DatabaseDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DatabaseDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, databasedetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, databasedetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, databasedetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, databasedetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, databasedetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, databasedetectorresult.FieldMessages)
	}
	if m.uris != nil {
		fields = append(fields, databasedetectorresult.FieldUris)
	}
	if m.results != nil {
		fields = append(fields, databasedetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DatabaseDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case databasedetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case databasedetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case databasedetectorresult.FieldTask:
		return m.Task()
	case databasedetectorresult.FieldResult:
		return m.Result()
	case databasedetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case databasedetectorresult.FieldMessages:
		return m.Messages()
	case databasedetectorresult.FieldUris:
		return m.Uris()
	case databasedetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DatabaseDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case databasedetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case databasedetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case databasedetectorresult.FieldTask:
		return m.OldTask(ctx)
	case databasedetectorresult.FieldResult:
		return m.OldResult(ctx)
	case databasedetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case databasedetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case databasedetectorresult.FieldUris:
		return m.OldUris(ctx)
	case databasedetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown DatabaseDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DatabaseDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case databasedetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case databasedetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case databasedetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case databasedetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case databasedetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case databasedetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case databasedetectorresult.FieldUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUris(v)
		return nil
	case databasedetectorresult.FieldResults:
		v, ok := value.(schema.DatabaseDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DatabaseDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, databasedetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, databasedetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, databasedetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DatabaseDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case databasedetectorresult.FieldTask:
		return m.AddedTask()
	case databasedetectorresult.FieldResult:
		return m.AddedResult()
	case databasedetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DatabaseDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case databasedetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case databasedetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case databasedetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DatabaseDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DatabaseDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DatabaseDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DatabaseDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DatabaseDetectorResultMutation) ResetField(name string) error {
	switch name {
	case databasedetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case databasedetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case databasedetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case databasedetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case databasedetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case databasedetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case databasedetectorresult.FieldUris:
		m.ResetUris()
		return nil
	case databasedetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown DatabaseDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DatabaseDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DatabaseDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DatabaseDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DatabaseDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DatabaseDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DatabaseDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DatabaseDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DatabaseDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DatabaseDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DatabaseDetectorResult edge %s", name)
}

// HTTPDetectorMutation represents an operation that mutates the HTTPDetector nodes in the graph.
type HTTPDetectorMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	status               *schema.Status
	addstatus            *schema.Status
	name                 *string
	owners               *[]string
	appendowners         []string
	receivers            *[]string
	appendreceivers      []string
	timeout              *string
	interval             *string
	description          *string
	ips                  *[]string
	appendips            []string
	url                  *string
	script               *string
	proxies              *[]string
	appendproxies        []string
	randomQueryString    *int8
	addrandomQueryString *int8
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*HTTPDetector, error)
	predicates           []predicate.HTTPDetector
}

var _ ent.Mutation = (*HTTPDetectorMutation)(nil)

// httpdetectorOption allows management of the mutation configuration using functional options.
type httpdetectorOption func(*HTTPDetectorMutation)

// newHTTPDetectorMutation creates new mutation for the HTTPDetector entity.
func newHTTPDetectorMutation(c config, op Op, opts ...httpdetectorOption) *HTTPDetectorMutation {
	m := &HTTPDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeHTTPDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHTTPDetectorID sets the ID field of the mutation.
func withHTTPDetectorID(id int) httpdetectorOption {
	return func(m *HTTPDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *HTTPDetector
		)
		m.oldValue = func(ctx context.Context) (*HTTPDetector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HTTPDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHTTPDetector sets the old HTTPDetector of the mutation.
func withHTTPDetector(node *HTTPDetector) httpdetectorOption {
	return func(m *HTTPDetectorMutation) {
		m.oldValue = func(context.Context) (*HTTPDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HTTPDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HTTPDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HTTPDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HTTPDetectorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HTTPDetector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HTTPDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HTTPDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HTTPDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HTTPDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HTTPDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HTTPDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *HTTPDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *HTTPDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *HTTPDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *HTTPDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *HTTPDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *HTTPDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HTTPDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HTTPDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwners sets the "owners" field.
func (m *HTTPDetectorMutation) SetOwners(s []string) {
	m.owners = &s
	m.appendowners = nil
}

// Owners returns the value of the "owners" field in the mutation.
func (m *HTTPDetectorMutation) Owners() (r []string, exists bool) {
	v := m.owners
	if v == nil {
		return
	}
	return *v, true
}

// OldOwners returns the old "owners" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldOwners(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwners: %w", err)
	}
	return oldValue.Owners, nil
}

// AppendOwners adds s to the "owners" field.
func (m *HTTPDetectorMutation) AppendOwners(s []string) {
	m.appendowners = append(m.appendowners, s...)
}

// AppendedOwners returns the list of values that were appended to the "owners" field in this mutation.
func (m *HTTPDetectorMutation) AppendedOwners() ([]string, bool) {
	if len(m.appendowners) == 0 {
		return nil, false
	}
	return m.appendowners, true
}

// ResetOwners resets all changes to the "owners" field.
func (m *HTTPDetectorMutation) ResetOwners() {
	m.owners = nil
	m.appendowners = nil
}

// SetReceivers sets the "receivers" field.
func (m *HTTPDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *HTTPDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds s to the "receivers" field.
func (m *HTTPDetectorMutation) AppendReceivers(s []string) {
	m.appendreceivers = append(m.appendreceivers, s...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *HTTPDetectorMutation) AppendedReceivers() ([]string, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *HTTPDetectorMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *HTTPDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *HTTPDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *HTTPDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetInterval sets the "interval" field.
func (m *HTTPDetectorMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *HTTPDetectorMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ClearInterval clears the value of the "interval" field.
func (m *HTTPDetectorMutation) ClearInterval() {
	m.interval = nil
	m.clearedFields[httpdetector.FieldInterval] = struct{}{}
}

// IntervalCleared returns if the "interval" field was cleared in this mutation.
func (m *HTTPDetectorMutation) IntervalCleared() bool {
	_, ok := m.clearedFields[httpdetector.FieldInterval]
	return ok
}

// ResetInterval resets all changes to the "interval" field.
func (m *HTTPDetectorMutation) ResetInterval() {
	m.interval = nil
	delete(m.clearedFields, httpdetector.FieldInterval)
}

// SetDescription sets the "description" field.
func (m *HTTPDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HTTPDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HTTPDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetIps sets the "ips" field.
func (m *HTTPDetectorMutation) SetIps(s []string) {
	m.ips = &s
	m.appendips = nil
}

// Ips returns the value of the "ips" field in the mutation.
func (m *HTTPDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// AppendIps adds s to the "ips" field.
func (m *HTTPDetectorMutation) AppendIps(s []string) {
	m.appendips = append(m.appendips, s...)
}

// AppendedIps returns the list of values that were appended to the "ips" field in this mutation.
func (m *HTTPDetectorMutation) AppendedIps() ([]string, bool) {
	if len(m.appendips) == 0 {
		return nil, false
	}
	return m.appendips, true
}

// ResetIps resets all changes to the "ips" field.
func (m *HTTPDetectorMutation) ResetIps() {
	m.ips = nil
	m.appendips = nil
}

// SetURL sets the "url" field.
func (m *HTTPDetectorMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *HTTPDetectorMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *HTTPDetectorMutation) ResetURL() {
	m.url = nil
}

// SetScript sets the "script" field.
func (m *HTTPDetectorMutation) SetScript(s string) {
	m.script = &s
}

// Script returns the value of the "script" field in the mutation.
func (m *HTTPDetectorMutation) Script() (r string, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldScript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ClearScript clears the value of the "script" field.
func (m *HTTPDetectorMutation) ClearScript() {
	m.script = nil
	m.clearedFields[httpdetector.FieldScript] = struct{}{}
}

// ScriptCleared returns if the "script" field was cleared in this mutation.
func (m *HTTPDetectorMutation) ScriptCleared() bool {
	_, ok := m.clearedFields[httpdetector.FieldScript]
	return ok
}

// ResetScript resets all changes to the "script" field.
func (m *HTTPDetectorMutation) ResetScript() {
	m.script = nil
	delete(m.clearedFields, httpdetector.FieldScript)
}

// SetProxies sets the "proxies" field.
func (m *HTTPDetectorMutation) SetProxies(s []string) {
	m.proxies = &s
	m.appendproxies = nil
}

// Proxies returns the value of the "proxies" field in the mutation.
func (m *HTTPDetectorMutation) Proxies() (r []string, exists bool) {
	v := m.proxies
	if v == nil {
		return
	}
	return *v, true
}

// OldProxies returns the old "proxies" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldProxies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxies: %w", err)
	}
	return oldValue.Proxies, nil
}

// AppendProxies adds s to the "proxies" field.
func (m *HTTPDetectorMutation) AppendProxies(s []string) {
	m.appendproxies = append(m.appendproxies, s...)
}

// AppendedProxies returns the list of values that were appended to the "proxies" field in this mutation.
func (m *HTTPDetectorMutation) AppendedProxies() ([]string, bool) {
	if len(m.appendproxies) == 0 {
		return nil, false
	}
	return m.appendproxies, true
}

// ClearProxies clears the value of the "proxies" field.
func (m *HTTPDetectorMutation) ClearProxies() {
	m.proxies = nil
	m.appendproxies = nil
	m.clearedFields[httpdetector.FieldProxies] = struct{}{}
}

// ProxiesCleared returns if the "proxies" field was cleared in this mutation.
func (m *HTTPDetectorMutation) ProxiesCleared() bool {
	_, ok := m.clearedFields[httpdetector.FieldProxies]
	return ok
}

// ResetProxies resets all changes to the "proxies" field.
func (m *HTTPDetectorMutation) ResetProxies() {
	m.proxies = nil
	m.appendproxies = nil
	delete(m.clearedFields, httpdetector.FieldProxies)
}

// SetRandomQueryString sets the "randomQueryString" field.
func (m *HTTPDetectorMutation) SetRandomQueryString(i int8) {
	m.randomQueryString = &i
	m.addrandomQueryString = nil
}

// RandomQueryString returns the value of the "randomQueryString" field in the mutation.
func (m *HTTPDetectorMutation) RandomQueryString() (r int8, exists bool) {
	v := m.randomQueryString
	if v == nil {
		return
	}
	return *v, true
}

// OldRandomQueryString returns the old "randomQueryString" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldRandomQueryString(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRandomQueryString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRandomQueryString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRandomQueryString: %w", err)
	}
	return oldValue.RandomQueryString, nil
}

// AddRandomQueryString adds i to the "randomQueryString" field.
func (m *HTTPDetectorMutation) AddRandomQueryString(i int8) {
	if m.addrandomQueryString != nil {
		*m.addrandomQueryString += i
	} else {
		m.addrandomQueryString = &i
	}
}

// AddedRandomQueryString returns the value that was added to the "randomQueryString" field in this mutation.
func (m *HTTPDetectorMutation) AddedRandomQueryString() (r int8, exists bool) {
	v := m.addrandomQueryString
	if v == nil {
		return
	}
	return *v, true
}

// ClearRandomQueryString clears the value of the "randomQueryString" field.
func (m *HTTPDetectorMutation) ClearRandomQueryString() {
	m.randomQueryString = nil
	m.addrandomQueryString = nil
	m.clearedFields[httpdetector.FieldRandomQueryString] = struct{}{}
}

// RandomQueryStringCleared returns if the "randomQueryString" field was cleared in this mutation.
func (m *HTTPDetectorMutation) RandomQueryStringCleared() bool {
	_, ok := m.clearedFields[httpdetector.FieldRandomQueryString]
	return ok
}

// ResetRandomQueryString resets all changes to the "randomQueryString" field.
func (m *HTTPDetectorMutation) ResetRandomQueryString() {
	m.randomQueryString = nil
	m.addrandomQueryString = nil
	delete(m.clearedFields, httpdetector.FieldRandomQueryString)
}

// Where appends a list predicates to the HTTPDetectorMutation builder.
func (m *HTTPDetectorMutation) Where(ps ...predicate.HTTPDetector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HTTPDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HTTPDetector).
func (m *HTTPDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HTTPDetectorMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, httpdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, httpdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, httpdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, httpdetector.FieldName)
	}
	if m.owners != nil {
		fields = append(fields, httpdetector.FieldOwners)
	}
	if m.receivers != nil {
		fields = append(fields, httpdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, httpdetector.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, httpdetector.FieldInterval)
	}
	if m.description != nil {
		fields = append(fields, httpdetector.FieldDescription)
	}
	if m.ips != nil {
		fields = append(fields, httpdetector.FieldIps)
	}
	if m.url != nil {
		fields = append(fields, httpdetector.FieldURL)
	}
	if m.script != nil {
		fields = append(fields, httpdetector.FieldScript)
	}
	if m.proxies != nil {
		fields = append(fields, httpdetector.FieldProxies)
	}
	if m.randomQueryString != nil {
		fields = append(fields, httpdetector.FieldRandomQueryString)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HTTPDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case httpdetector.FieldCreatedAt:
		return m.CreatedAt()
	case httpdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case httpdetector.FieldStatus:
		return m.Status()
	case httpdetector.FieldName:
		return m.Name()
	case httpdetector.FieldOwners:
		return m.Owners()
	case httpdetector.FieldReceivers:
		return m.Receivers()
	case httpdetector.FieldTimeout:
		return m.Timeout()
	case httpdetector.FieldInterval:
		return m.Interval()
	case httpdetector.FieldDescription:
		return m.Description()
	case httpdetector.FieldIps:
		return m.Ips()
	case httpdetector.FieldURL:
		return m.URL()
	case httpdetector.FieldScript:
		return m.Script()
	case httpdetector.FieldProxies:
		return m.Proxies()
	case httpdetector.FieldRandomQueryString:
		return m.RandomQueryString()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HTTPDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case httpdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case httpdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case httpdetector.FieldStatus:
		return m.OldStatus(ctx)
	case httpdetector.FieldName:
		return m.OldName(ctx)
	case httpdetector.FieldOwners:
		return m.OldOwners(ctx)
	case httpdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case httpdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case httpdetector.FieldInterval:
		return m.OldInterval(ctx)
	case httpdetector.FieldDescription:
		return m.OldDescription(ctx)
	case httpdetector.FieldIps:
		return m.OldIps(ctx)
	case httpdetector.FieldURL:
		return m.OldURL(ctx)
	case httpdetector.FieldScript:
		return m.OldScript(ctx)
	case httpdetector.FieldProxies:
		return m.OldProxies(ctx)
	case httpdetector.FieldRandomQueryString:
		return m.OldRandomQueryString(ctx)
	}
	return nil, fmt.Errorf("unknown HTTPDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case httpdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case httpdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case httpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case httpdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case httpdetector.FieldOwners:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwners(v)
		return nil
	case httpdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case httpdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case httpdetector.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case httpdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case httpdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case httpdetector.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case httpdetector.FieldScript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	case httpdetector.FieldProxies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxies(v)
		return nil
	case httpdetector.FieldRandomQueryString:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRandomQueryString(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HTTPDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, httpdetector.FieldStatus)
	}
	if m.addrandomQueryString != nil {
		fields = append(fields, httpdetector.FieldRandomQueryString)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HTTPDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case httpdetector.FieldStatus:
		return m.AddedStatus()
	case httpdetector.FieldRandomQueryString:
		return m.AddedRandomQueryString()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case httpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case httpdetector.FieldRandomQueryString:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRandomQueryString(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HTTPDetectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(httpdetector.FieldInterval) {
		fields = append(fields, httpdetector.FieldInterval)
	}
	if m.FieldCleared(httpdetector.FieldScript) {
		fields = append(fields, httpdetector.FieldScript)
	}
	if m.FieldCleared(httpdetector.FieldProxies) {
		fields = append(fields, httpdetector.FieldProxies)
	}
	if m.FieldCleared(httpdetector.FieldRandomQueryString) {
		fields = append(fields, httpdetector.FieldRandomQueryString)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HTTPDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HTTPDetectorMutation) ClearField(name string) error {
	switch name {
	case httpdetector.FieldInterval:
		m.ClearInterval()
		return nil
	case httpdetector.FieldScript:
		m.ClearScript()
		return nil
	case httpdetector.FieldProxies:
		m.ClearProxies()
		return nil
	case httpdetector.FieldRandomQueryString:
		m.ClearRandomQueryString()
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HTTPDetectorMutation) ResetField(name string) error {
	switch name {
	case httpdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case httpdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case httpdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case httpdetector.FieldName:
		m.ResetName()
		return nil
	case httpdetector.FieldOwners:
		m.ResetOwners()
		return nil
	case httpdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case httpdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case httpdetector.FieldInterval:
		m.ResetInterval()
		return nil
	case httpdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case httpdetector.FieldIps:
		m.ResetIps()
		return nil
	case httpdetector.FieldURL:
		m.ResetURL()
		return nil
	case httpdetector.FieldScript:
		m.ResetScript()
		return nil
	case httpdetector.FieldProxies:
		m.ResetProxies()
		return nil
	case httpdetector.FieldRandomQueryString:
		m.ResetRandomQueryString()
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HTTPDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HTTPDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HTTPDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HTTPDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HTTPDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HTTPDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HTTPDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HTTPDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetector edge %s", name)
}

// HTTPDetectorResultMutation represents an operation that mutates the HTTPDetectorResult nodes in the graph.
type HTTPDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *schema.DetectorResult
	addresult      *schema.DetectorResult
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	appendmessages []string
	url            *string
	results        *schema.HTTPDetectorSubResults
	appendresults  schema.HTTPDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*HTTPDetectorResult, error)
	predicates     []predicate.HTTPDetectorResult
}

var _ ent.Mutation = (*HTTPDetectorResultMutation)(nil)

// httpdetectorresultOption allows management of the mutation configuration using functional options.
type httpdetectorresultOption func(*HTTPDetectorResultMutation)

// newHTTPDetectorResultMutation creates new mutation for the HTTPDetectorResult entity.
func newHTTPDetectorResultMutation(c config, op Op, opts ...httpdetectorresultOption) *HTTPDetectorResultMutation {
	m := &HTTPDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeHTTPDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHTTPDetectorResultID sets the ID field of the mutation.
func withHTTPDetectorResultID(id int) httpdetectorresultOption {
	return func(m *HTTPDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *HTTPDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*HTTPDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HTTPDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHTTPDetectorResult sets the old HTTPDetectorResult of the mutation.
func withHTTPDetectorResult(node *HTTPDetectorResult) httpdetectorresultOption {
	return func(m *HTTPDetectorResultMutation) {
		m.oldValue = func(context.Context) (*HTTPDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HTTPDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HTTPDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HTTPDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HTTPDetectorResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HTTPDetectorResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HTTPDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HTTPDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HTTPDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HTTPDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HTTPDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HTTPDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *HTTPDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *HTTPDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *HTTPDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *HTTPDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *HTTPDetectorResultMutation) SetResult(sr schema.DetectorResult) {
	m.result = &sr
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *HTTPDetectorResultMutation) Result() (r schema.DetectorResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldResult(ctx context.Context) (v schema.DetectorResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds sr to the "result" field.
func (m *HTTPDetectorResultMutation) AddResult(sr schema.DetectorResult) {
	if m.addresult != nil {
		*m.addresult += sr
	} else {
		m.addresult = &sr
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedResult() (r schema.DetectorResult, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *HTTPDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *HTTPDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *HTTPDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *HTTPDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *HTTPDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *HTTPDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *HTTPDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *HTTPDetectorResultMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *HTTPDetectorResultMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ResetMessages resets all changes to the "messages" field.
func (m *HTTPDetectorResultMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
}

// SetURL sets the "url" field.
func (m *HTTPDetectorResultMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *HTTPDetectorResultMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *HTTPDetectorResultMutation) ResetURL() {
	m.url = nil
}

// SetResults sets the "results" field.
func (m *HTTPDetectorResultMutation) SetResults(sdsr schema.HTTPDetectorSubResults) {
	m.results = &sdsr
	m.appendresults = nil
}

// Results returns the value of the "results" field in the mutation.
func (m *HTTPDetectorResultMutation) Results() (r schema.HTTPDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldResults(ctx context.Context) (v schema.HTTPDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// AppendResults adds sdsr to the "results" field.
func (m *HTTPDetectorResultMutation) AppendResults(sdsr schema.HTTPDetectorSubResults) {
	m.appendresults = append(m.appendresults, sdsr...)
}

// AppendedResults returns the list of values that were appended to the "results" field in this mutation.
func (m *HTTPDetectorResultMutation) AppendedResults() (schema.HTTPDetectorSubResults, bool) {
	if len(m.appendresults) == 0 {
		return nil, false
	}
	return m.appendresults, true
}

// ResetResults resets all changes to the "results" field.
func (m *HTTPDetectorResultMutation) ResetResults() {
	m.results = nil
	m.appendresults = nil
}

// Where appends a list predicates to the HTTPDetectorResultMutation builder.
func (m *HTTPDetectorResultMutation) Where(ps ...predicate.HTTPDetectorResult) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HTTPDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HTTPDetectorResult).
func (m *HTTPDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HTTPDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, httpdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, httpdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, httpdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, httpdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, httpdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, httpdetectorresult.FieldMessages)
	}
	if m.url != nil {
		fields = append(fields, httpdetectorresult.FieldURL)
	}
	if m.results != nil {
		fields = append(fields, httpdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HTTPDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case httpdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case httpdetectorresult.FieldTask:
		return m.Task()
	case httpdetectorresult.FieldResult:
		return m.Result()
	case httpdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case httpdetectorresult.FieldMessages:
		return m.Messages()
	case httpdetectorresult.FieldURL:
		return m.URL()
	case httpdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HTTPDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case httpdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case httpdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case httpdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case httpdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case httpdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case httpdetectorresult.FieldURL:
		return m.OldURL(ctx)
	case httpdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case httpdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case httpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case httpdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case httpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case httpdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case httpdetectorresult.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case httpdetectorresult.FieldResults:
		v, ok := value.(schema.HTTPDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HTTPDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, httpdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, httpdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, httpdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HTTPDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case httpdetectorresult.FieldTask:
		return m.AddedTask()
	case httpdetectorresult.FieldResult:
		return m.AddedResult()
	case httpdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case httpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case httpdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case httpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HTTPDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HTTPDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HTTPDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HTTPDetectorResultMutation) ResetField(name string) error {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case httpdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case httpdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case httpdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case httpdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case httpdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case httpdetectorresult.FieldURL:
		m.ResetURL()
		return nil
	case httpdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HTTPDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HTTPDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HTTPDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HTTPDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HTTPDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HTTPDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HTTPDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HTTPDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult edge %s", name)
}

// PingDetectorMutation represents an operation that mutates the PingDetector nodes in the graph.
type PingDetectorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	status          *schema.Status
	addstatus       *schema.Status
	name            *string
	owners          *[]string
	appendowners    []string
	receivers       *[]string
	appendreceivers []string
	timeout         *string
	interval        *string
	description     *string
	ips             *[]string
	appendips       []string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PingDetector, error)
	predicates      []predicate.PingDetector
}

var _ ent.Mutation = (*PingDetectorMutation)(nil)

// pingdetectorOption allows management of the mutation configuration using functional options.
type pingdetectorOption func(*PingDetectorMutation)

// newPingDetectorMutation creates new mutation for the PingDetector entity.
func newPingDetectorMutation(c config, op Op, opts ...pingdetectorOption) *PingDetectorMutation {
	m := &PingDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypePingDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPingDetectorID sets the ID field of the mutation.
func withPingDetectorID(id int) pingdetectorOption {
	return func(m *PingDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *PingDetector
		)
		m.oldValue = func(ctx context.Context) (*PingDetector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PingDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPingDetector sets the old PingDetector of the mutation.
func withPingDetector(node *PingDetector) pingdetectorOption {
	return func(m *PingDetectorMutation) {
		m.oldValue = func(context.Context) (*PingDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PingDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PingDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PingDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PingDetectorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PingDetector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PingDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PingDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PingDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PingDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PingDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PingDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PingDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PingDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *PingDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PingDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PingDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *PingDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PingDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PingDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwners sets the "owners" field.
func (m *PingDetectorMutation) SetOwners(s []string) {
	m.owners = &s
	m.appendowners = nil
}

// Owners returns the value of the "owners" field in the mutation.
func (m *PingDetectorMutation) Owners() (r []string, exists bool) {
	v := m.owners
	if v == nil {
		return
	}
	return *v, true
}

// OldOwners returns the old "owners" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldOwners(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwners: %w", err)
	}
	return oldValue.Owners, nil
}

// AppendOwners adds s to the "owners" field.
func (m *PingDetectorMutation) AppendOwners(s []string) {
	m.appendowners = append(m.appendowners, s...)
}

// AppendedOwners returns the list of values that were appended to the "owners" field in this mutation.
func (m *PingDetectorMutation) AppendedOwners() ([]string, bool) {
	if len(m.appendowners) == 0 {
		return nil, false
	}
	return m.appendowners, true
}

// ResetOwners resets all changes to the "owners" field.
func (m *PingDetectorMutation) ResetOwners() {
	m.owners = nil
	m.appendowners = nil
}

// SetReceivers sets the "receivers" field.
func (m *PingDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *PingDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds s to the "receivers" field.
func (m *PingDetectorMutation) AppendReceivers(s []string) {
	m.appendreceivers = append(m.appendreceivers, s...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *PingDetectorMutation) AppendedReceivers() ([]string, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *PingDetectorMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *PingDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *PingDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *PingDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetInterval sets the "interval" field.
func (m *PingDetectorMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *PingDetectorMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ClearInterval clears the value of the "interval" field.
func (m *PingDetectorMutation) ClearInterval() {
	m.interval = nil
	m.clearedFields[pingdetector.FieldInterval] = struct{}{}
}

// IntervalCleared returns if the "interval" field was cleared in this mutation.
func (m *PingDetectorMutation) IntervalCleared() bool {
	_, ok := m.clearedFields[pingdetector.FieldInterval]
	return ok
}

// ResetInterval resets all changes to the "interval" field.
func (m *PingDetectorMutation) ResetInterval() {
	m.interval = nil
	delete(m.clearedFields, pingdetector.FieldInterval)
}

// SetDescription sets the "description" field.
func (m *PingDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PingDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PingDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetIps sets the "ips" field.
func (m *PingDetectorMutation) SetIps(s []string) {
	m.ips = &s
	m.appendips = nil
}

// Ips returns the value of the "ips" field in the mutation.
func (m *PingDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// AppendIps adds s to the "ips" field.
func (m *PingDetectorMutation) AppendIps(s []string) {
	m.appendips = append(m.appendips, s...)
}

// AppendedIps returns the list of values that were appended to the "ips" field in this mutation.
func (m *PingDetectorMutation) AppendedIps() ([]string, bool) {
	if len(m.appendips) == 0 {
		return nil, false
	}
	return m.appendips, true
}

// ResetIps resets all changes to the "ips" field.
func (m *PingDetectorMutation) ResetIps() {
	m.ips = nil
	m.appendips = nil
}

// Where appends a list predicates to the PingDetectorMutation builder.
func (m *PingDetectorMutation) Where(ps ...predicate.PingDetector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PingDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PingDetector).
func (m *PingDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PingDetectorMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, pingdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pingdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, pingdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, pingdetector.FieldName)
	}
	if m.owners != nil {
		fields = append(fields, pingdetector.FieldOwners)
	}
	if m.receivers != nil {
		fields = append(fields, pingdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, pingdetector.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, pingdetector.FieldInterval)
	}
	if m.description != nil {
		fields = append(fields, pingdetector.FieldDescription)
	}
	if m.ips != nil {
		fields = append(fields, pingdetector.FieldIps)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PingDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pingdetector.FieldCreatedAt:
		return m.CreatedAt()
	case pingdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case pingdetector.FieldStatus:
		return m.Status()
	case pingdetector.FieldName:
		return m.Name()
	case pingdetector.FieldOwners:
		return m.Owners()
	case pingdetector.FieldReceivers:
		return m.Receivers()
	case pingdetector.FieldTimeout:
		return m.Timeout()
	case pingdetector.FieldInterval:
		return m.Interval()
	case pingdetector.FieldDescription:
		return m.Description()
	case pingdetector.FieldIps:
		return m.Ips()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PingDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pingdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pingdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pingdetector.FieldStatus:
		return m.OldStatus(ctx)
	case pingdetector.FieldName:
		return m.OldName(ctx)
	case pingdetector.FieldOwners:
		return m.OldOwners(ctx)
	case pingdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case pingdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case pingdetector.FieldInterval:
		return m.OldInterval(ctx)
	case pingdetector.FieldDescription:
		return m.OldDescription(ctx)
	case pingdetector.FieldIps:
		return m.OldIps(ctx)
	}
	return nil, fmt.Errorf("unknown PingDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pingdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pingdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pingdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pingdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pingdetector.FieldOwners:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwners(v)
		return nil
	case pingdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case pingdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case pingdetector.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case pingdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case pingdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PingDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, pingdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PingDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pingdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pingdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PingDetectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pingdetector.FieldInterval) {
		fields = append(fields, pingdetector.FieldInterval)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PingDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PingDetectorMutation) ClearField(name string) error {
	switch name {
	case pingdetector.FieldInterval:
		m.ClearInterval()
		return nil
	}
	return fmt.Errorf("unknown PingDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PingDetectorMutation) ResetField(name string) error {
	switch name {
	case pingdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pingdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pingdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case pingdetector.FieldName:
		m.ResetName()
		return nil
	case pingdetector.FieldOwners:
		m.ResetOwners()
		return nil
	case pingdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case pingdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case pingdetector.FieldInterval:
		m.ResetInterval()
		return nil
	case pingdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case pingdetector.FieldIps:
		m.ResetIps()
		return nil
	}
	return fmt.Errorf("unknown PingDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PingDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PingDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PingDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PingDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PingDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PingDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PingDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PingDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PingDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PingDetector edge %s", name)
}

// PingDetectorResultMutation represents an operation that mutates the PingDetectorResult nodes in the graph.
type PingDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *schema.DetectorResult
	addresult      *schema.DetectorResult
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	appendmessages []string
	ips            *[]string
	appendips      []string
	results        *schema.PingDetectorSubResults
	appendresults  schema.PingDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PingDetectorResult, error)
	predicates     []predicate.PingDetectorResult
}

var _ ent.Mutation = (*PingDetectorResultMutation)(nil)

// pingdetectorresultOption allows management of the mutation configuration using functional options.
type pingdetectorresultOption func(*PingDetectorResultMutation)

// newPingDetectorResultMutation creates new mutation for the PingDetectorResult entity.
func newPingDetectorResultMutation(c config, op Op, opts ...pingdetectorresultOption) *PingDetectorResultMutation {
	m := &PingDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypePingDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPingDetectorResultID sets the ID field of the mutation.
func withPingDetectorResultID(id int) pingdetectorresultOption {
	return func(m *PingDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *PingDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*PingDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PingDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPingDetectorResult sets the old PingDetectorResult of the mutation.
func withPingDetectorResult(node *PingDetectorResult) pingdetectorresultOption {
	return func(m *PingDetectorResultMutation) {
		m.oldValue = func(context.Context) (*PingDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PingDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PingDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PingDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PingDetectorResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PingDetectorResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PingDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PingDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PingDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PingDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PingDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PingDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *PingDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *PingDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *PingDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *PingDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *PingDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *PingDetectorResultMutation) SetResult(sr schema.DetectorResult) {
	m.result = &sr
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *PingDetectorResultMutation) Result() (r schema.DetectorResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldResult(ctx context.Context) (v schema.DetectorResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds sr to the "result" field.
func (m *PingDetectorResultMutation) AddResult(sr schema.DetectorResult) {
	if m.addresult != nil {
		*m.addresult += sr
	} else {
		m.addresult = &sr
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *PingDetectorResultMutation) AddedResult() (r schema.DetectorResult, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *PingDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *PingDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *PingDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *PingDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *PingDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *PingDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *PingDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *PingDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *PingDetectorResultMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *PingDetectorResultMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ResetMessages resets all changes to the "messages" field.
func (m *PingDetectorResultMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
}

// SetIps sets the "ips" field.
func (m *PingDetectorResultMutation) SetIps(s []string) {
	m.ips = &s
	m.appendips = nil
}

// Ips returns the value of the "ips" field in the mutation.
func (m *PingDetectorResultMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// AppendIps adds s to the "ips" field.
func (m *PingDetectorResultMutation) AppendIps(s []string) {
	m.appendips = append(m.appendips, s...)
}

// AppendedIps returns the list of values that were appended to the "ips" field in this mutation.
func (m *PingDetectorResultMutation) AppendedIps() ([]string, bool) {
	if len(m.appendips) == 0 {
		return nil, false
	}
	return m.appendips, true
}

// ResetIps resets all changes to the "ips" field.
func (m *PingDetectorResultMutation) ResetIps() {
	m.ips = nil
	m.appendips = nil
}

// SetResults sets the "results" field.
func (m *PingDetectorResultMutation) SetResults(sdsr schema.PingDetectorSubResults) {
	m.results = &sdsr
	m.appendresults = nil
}

// Results returns the value of the "results" field in the mutation.
func (m *PingDetectorResultMutation) Results() (r schema.PingDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldResults(ctx context.Context) (v schema.PingDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// AppendResults adds sdsr to the "results" field.
func (m *PingDetectorResultMutation) AppendResults(sdsr schema.PingDetectorSubResults) {
	m.appendresults = append(m.appendresults, sdsr...)
}

// AppendedResults returns the list of values that were appended to the "results" field in this mutation.
func (m *PingDetectorResultMutation) AppendedResults() (schema.PingDetectorSubResults, bool) {
	if len(m.appendresults) == 0 {
		return nil, false
	}
	return m.appendresults, true
}

// ResetResults resets all changes to the "results" field.
func (m *PingDetectorResultMutation) ResetResults() {
	m.results = nil
	m.appendresults = nil
}

// Where appends a list predicates to the PingDetectorResultMutation builder.
func (m *PingDetectorResultMutation) Where(ps ...predicate.PingDetectorResult) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PingDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PingDetectorResult).
func (m *PingDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PingDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, pingdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pingdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, pingdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, pingdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, pingdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, pingdetectorresult.FieldMessages)
	}
	if m.ips != nil {
		fields = append(fields, pingdetectorresult.FieldIps)
	}
	if m.results != nil {
		fields = append(fields, pingdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PingDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case pingdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case pingdetectorresult.FieldTask:
		return m.Task()
	case pingdetectorresult.FieldResult:
		return m.Result()
	case pingdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case pingdetectorresult.FieldMessages:
		return m.Messages()
	case pingdetectorresult.FieldIps:
		return m.Ips()
	case pingdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PingDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pingdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pingdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case pingdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case pingdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case pingdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case pingdetectorresult.FieldIps:
		return m.OldIps(ctx)
	case pingdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pingdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pingdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case pingdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case pingdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case pingdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case pingdetectorresult.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case pingdetectorresult.FieldResults:
		v, ok := value.(schema.PingDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PingDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, pingdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, pingdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, pingdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PingDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pingdetectorresult.FieldTask:
		return m.AddedTask()
	case pingdetectorresult.FieldResult:
		return m.AddedResult()
	case pingdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pingdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case pingdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case pingdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PingDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PingDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PingDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PingDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PingDetectorResultMutation) ResetField(name string) error {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pingdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pingdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case pingdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case pingdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case pingdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case pingdetectorresult.FieldIps:
		m.ResetIps()
		return nil
	case pingdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PingDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PingDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PingDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PingDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PingDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PingDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PingDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PingDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PingDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PingDetectorResult edge %s", name)
}

// TCPDetectorMutation represents an operation that mutates the TCPDetector nodes in the graph.
type TCPDetectorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	status          *schema.Status
	addstatus       *schema.Status
	name            *string
	owners          *[]string
	appendowners    []string
	receivers       *[]string
	appendreceivers []string
	timeout         *string
	interval        *string
	description     *string
	addrs           *[]string
	appendaddrs     []string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TCPDetector, error)
	predicates      []predicate.TCPDetector
}

var _ ent.Mutation = (*TCPDetectorMutation)(nil)

// tcpdetectorOption allows management of the mutation configuration using functional options.
type tcpdetectorOption func(*TCPDetectorMutation)

// newTCPDetectorMutation creates new mutation for the TCPDetector entity.
func newTCPDetectorMutation(c config, op Op, opts ...tcpdetectorOption) *TCPDetectorMutation {
	m := &TCPDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeTCPDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTCPDetectorID sets the ID field of the mutation.
func withTCPDetectorID(id int) tcpdetectorOption {
	return func(m *TCPDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *TCPDetector
		)
		m.oldValue = func(ctx context.Context) (*TCPDetector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TCPDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTCPDetector sets the old TCPDetector of the mutation.
func withTCPDetector(node *TCPDetector) tcpdetectorOption {
	return func(m *TCPDetectorMutation) {
		m.oldValue = func(context.Context) (*TCPDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TCPDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TCPDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TCPDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TCPDetectorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TCPDetector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TCPDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TCPDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TCPDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TCPDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TCPDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TCPDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TCPDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TCPDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *TCPDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TCPDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TCPDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *TCPDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TCPDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TCPDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwners sets the "owners" field.
func (m *TCPDetectorMutation) SetOwners(s []string) {
	m.owners = &s
	m.appendowners = nil
}

// Owners returns the value of the "owners" field in the mutation.
func (m *TCPDetectorMutation) Owners() (r []string, exists bool) {
	v := m.owners
	if v == nil {
		return
	}
	return *v, true
}

// OldOwners returns the old "owners" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldOwners(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwners: %w", err)
	}
	return oldValue.Owners, nil
}

// AppendOwners adds s to the "owners" field.
func (m *TCPDetectorMutation) AppendOwners(s []string) {
	m.appendowners = append(m.appendowners, s...)
}

// AppendedOwners returns the list of values that were appended to the "owners" field in this mutation.
func (m *TCPDetectorMutation) AppendedOwners() ([]string, bool) {
	if len(m.appendowners) == 0 {
		return nil, false
	}
	return m.appendowners, true
}

// ResetOwners resets all changes to the "owners" field.
func (m *TCPDetectorMutation) ResetOwners() {
	m.owners = nil
	m.appendowners = nil
}

// SetReceivers sets the "receivers" field.
func (m *TCPDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *TCPDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds s to the "receivers" field.
func (m *TCPDetectorMutation) AppendReceivers(s []string) {
	m.appendreceivers = append(m.appendreceivers, s...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *TCPDetectorMutation) AppendedReceivers() ([]string, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *TCPDetectorMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *TCPDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *TCPDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *TCPDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetInterval sets the "interval" field.
func (m *TCPDetectorMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *TCPDetectorMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ClearInterval clears the value of the "interval" field.
func (m *TCPDetectorMutation) ClearInterval() {
	m.interval = nil
	m.clearedFields[tcpdetector.FieldInterval] = struct{}{}
}

// IntervalCleared returns if the "interval" field was cleared in this mutation.
func (m *TCPDetectorMutation) IntervalCleared() bool {
	_, ok := m.clearedFields[tcpdetector.FieldInterval]
	return ok
}

// ResetInterval resets all changes to the "interval" field.
func (m *TCPDetectorMutation) ResetInterval() {
	m.interval = nil
	delete(m.clearedFields, tcpdetector.FieldInterval)
}

// SetDescription sets the "description" field.
func (m *TCPDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TCPDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TCPDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetAddrs sets the "addrs" field.
func (m *TCPDetectorMutation) SetAddrs(s []string) {
	m.addrs = &s
	m.appendaddrs = nil
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *TCPDetectorMutation) Addrs() (r []string, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldAddrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// AppendAddrs adds s to the "addrs" field.
func (m *TCPDetectorMutation) AppendAddrs(s []string) {
	m.appendaddrs = append(m.appendaddrs, s...)
}

// AppendedAddrs returns the list of values that were appended to the "addrs" field in this mutation.
func (m *TCPDetectorMutation) AppendedAddrs() ([]string, bool) {
	if len(m.appendaddrs) == 0 {
		return nil, false
	}
	return m.appendaddrs, true
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *TCPDetectorMutation) ResetAddrs() {
	m.addrs = nil
	m.appendaddrs = nil
}

// Where appends a list predicates to the TCPDetectorMutation builder.
func (m *TCPDetectorMutation) Where(ps ...predicate.TCPDetector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TCPDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TCPDetector).
func (m *TCPDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TCPDetectorMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, tcpdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tcpdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tcpdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tcpdetector.FieldName)
	}
	if m.owners != nil {
		fields = append(fields, tcpdetector.FieldOwners)
	}
	if m.receivers != nil {
		fields = append(fields, tcpdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, tcpdetector.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, tcpdetector.FieldInterval)
	}
	if m.description != nil {
		fields = append(fields, tcpdetector.FieldDescription)
	}
	if m.addrs != nil {
		fields = append(fields, tcpdetector.FieldAddrs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TCPDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tcpdetector.FieldCreatedAt:
		return m.CreatedAt()
	case tcpdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case tcpdetector.FieldStatus:
		return m.Status()
	case tcpdetector.FieldName:
		return m.Name()
	case tcpdetector.FieldOwners:
		return m.Owners()
	case tcpdetector.FieldReceivers:
		return m.Receivers()
	case tcpdetector.FieldTimeout:
		return m.Timeout()
	case tcpdetector.FieldInterval:
		return m.Interval()
	case tcpdetector.FieldDescription:
		return m.Description()
	case tcpdetector.FieldAddrs:
		return m.Addrs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TCPDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tcpdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tcpdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tcpdetector.FieldStatus:
		return m.OldStatus(ctx)
	case tcpdetector.FieldName:
		return m.OldName(ctx)
	case tcpdetector.FieldOwners:
		return m.OldOwners(ctx)
	case tcpdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case tcpdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case tcpdetector.FieldInterval:
		return m.OldInterval(ctx)
	case tcpdetector.FieldDescription:
		return m.OldDescription(ctx)
	case tcpdetector.FieldAddrs:
		return m.OldAddrs(ctx)
	}
	return nil, fmt.Errorf("unknown TCPDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tcpdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tcpdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tcpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tcpdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tcpdetector.FieldOwners:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwners(v)
		return nil
	case tcpdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case tcpdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case tcpdetector.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case tcpdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tcpdetector.FieldAddrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TCPDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tcpdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TCPDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tcpdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tcpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TCPDetectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tcpdetector.FieldInterval) {
		fields = append(fields, tcpdetector.FieldInterval)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TCPDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TCPDetectorMutation) ClearField(name string) error {
	switch name {
	case tcpdetector.FieldInterval:
		m.ClearInterval()
		return nil
	}
	return fmt.Errorf("unknown TCPDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TCPDetectorMutation) ResetField(name string) error {
	switch name {
	case tcpdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tcpdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tcpdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case tcpdetector.FieldName:
		m.ResetName()
		return nil
	case tcpdetector.FieldOwners:
		m.ResetOwners()
		return nil
	case tcpdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case tcpdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case tcpdetector.FieldInterval:
		m.ResetInterval()
		return nil
	case tcpdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case tcpdetector.FieldAddrs:
		m.ResetAddrs()
		return nil
	}
	return fmt.Errorf("unknown TCPDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TCPDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TCPDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TCPDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TCPDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TCPDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TCPDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TCPDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TCPDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TCPDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TCPDetector edge %s", name)
}

// TCPDetectorResultMutation represents an operation that mutates the TCPDetectorResult nodes in the graph.
type TCPDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *schema.DetectorResult
	addresult      *schema.DetectorResult
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	appendmessages []string
	addrs          *[]string
	appendaddrs    []string
	results        *schema.TCPDetectorSubResults
	appendresults  schema.TCPDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TCPDetectorResult, error)
	predicates     []predicate.TCPDetectorResult
}

var _ ent.Mutation = (*TCPDetectorResultMutation)(nil)

// tcpdetectorresultOption allows management of the mutation configuration using functional options.
type tcpdetectorresultOption func(*TCPDetectorResultMutation)

// newTCPDetectorResultMutation creates new mutation for the TCPDetectorResult entity.
func newTCPDetectorResultMutation(c config, op Op, opts ...tcpdetectorresultOption) *TCPDetectorResultMutation {
	m := &TCPDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTCPDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTCPDetectorResultID sets the ID field of the mutation.
func withTCPDetectorResultID(id int) tcpdetectorresultOption {
	return func(m *TCPDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TCPDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*TCPDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TCPDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTCPDetectorResult sets the old TCPDetectorResult of the mutation.
func withTCPDetectorResult(node *TCPDetectorResult) tcpdetectorresultOption {
	return func(m *TCPDetectorResultMutation) {
		m.oldValue = func(context.Context) (*TCPDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TCPDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TCPDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TCPDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TCPDetectorResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TCPDetectorResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TCPDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TCPDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TCPDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TCPDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TCPDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TCPDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *TCPDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *TCPDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *TCPDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *TCPDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *TCPDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *TCPDetectorResultMutation) SetResult(sr schema.DetectorResult) {
	m.result = &sr
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *TCPDetectorResultMutation) Result() (r schema.DetectorResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldResult(ctx context.Context) (v schema.DetectorResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds sr to the "result" field.
func (m *TCPDetectorResultMutation) AddResult(sr schema.DetectorResult) {
	if m.addresult != nil {
		*m.addresult += sr
	} else {
		m.addresult = &sr
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *TCPDetectorResultMutation) AddedResult() (r schema.DetectorResult, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *TCPDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *TCPDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *TCPDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *TCPDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *TCPDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *TCPDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *TCPDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *TCPDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *TCPDetectorResultMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *TCPDetectorResultMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ResetMessages resets all changes to the "messages" field.
func (m *TCPDetectorResultMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
}

// SetAddrs sets the "addrs" field.
func (m *TCPDetectorResultMutation) SetAddrs(s []string) {
	m.addrs = &s
	m.appendaddrs = nil
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *TCPDetectorResultMutation) Addrs() (r []string, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldAddrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// AppendAddrs adds s to the "addrs" field.
func (m *TCPDetectorResultMutation) AppendAddrs(s []string) {
	m.appendaddrs = append(m.appendaddrs, s...)
}

// AppendedAddrs returns the list of values that were appended to the "addrs" field in this mutation.
func (m *TCPDetectorResultMutation) AppendedAddrs() ([]string, bool) {
	if len(m.appendaddrs) == 0 {
		return nil, false
	}
	return m.appendaddrs, true
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *TCPDetectorResultMutation) ResetAddrs() {
	m.addrs = nil
	m.appendaddrs = nil
}

// SetResults sets the "results" field.
func (m *TCPDetectorResultMutation) SetResults(sdsr schema.TCPDetectorSubResults) {
	m.results = &sdsr
	m.appendresults = nil
}

// Results returns the value of the "results" field in the mutation.
func (m *TCPDetectorResultMutation) Results() (r schema.TCPDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldResults(ctx context.Context) (v schema.TCPDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// AppendResults adds sdsr to the "results" field.
func (m *TCPDetectorResultMutation) AppendResults(sdsr schema.TCPDetectorSubResults) {
	m.appendresults = append(m.appendresults, sdsr...)
}

// AppendedResults returns the list of values that were appended to the "results" field in this mutation.
func (m *TCPDetectorResultMutation) AppendedResults() (schema.TCPDetectorSubResults, bool) {
	if len(m.appendresults) == 0 {
		return nil, false
	}
	return m.appendresults, true
}

// ResetResults resets all changes to the "results" field.
func (m *TCPDetectorResultMutation) ResetResults() {
	m.results = nil
	m.appendresults = nil
}

// Where appends a list predicates to the TCPDetectorResultMutation builder.
func (m *TCPDetectorResultMutation) Where(ps ...predicate.TCPDetectorResult) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TCPDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TCPDetectorResult).
func (m *TCPDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TCPDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, tcpdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tcpdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, tcpdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, tcpdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, tcpdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, tcpdetectorresult.FieldMessages)
	}
	if m.addrs != nil {
		fields = append(fields, tcpdetectorresult.FieldAddrs)
	}
	if m.results != nil {
		fields = append(fields, tcpdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TCPDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case tcpdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case tcpdetectorresult.FieldTask:
		return m.Task()
	case tcpdetectorresult.FieldResult:
		return m.Result()
	case tcpdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case tcpdetectorresult.FieldMessages:
		return m.Messages()
	case tcpdetectorresult.FieldAddrs:
		return m.Addrs()
	case tcpdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TCPDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tcpdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tcpdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case tcpdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case tcpdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case tcpdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case tcpdetectorresult.FieldAddrs:
		return m.OldAddrs(ctx)
	case tcpdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tcpdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tcpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case tcpdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case tcpdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case tcpdetectorresult.FieldAddrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	case tcpdetectorresult.FieldResults:
		v, ok := value.(schema.TCPDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TCPDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, tcpdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, tcpdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, tcpdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TCPDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tcpdetectorresult.FieldTask:
		return m.AddedTask()
	case tcpdetectorresult.FieldResult:
		return m.AddedResult()
	case tcpdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tcpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case tcpdetectorresult.FieldResult:
		v, ok := value.(schema.DetectorResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TCPDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TCPDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TCPDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TCPDetectorResultMutation) ResetField(name string) error {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tcpdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tcpdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case tcpdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case tcpdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case tcpdetectorresult.FieldAddrs:
		m.ResetAddrs()
		return nil
	case tcpdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TCPDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TCPDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TCPDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TCPDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TCPDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TCPDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TCPDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TCPDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	account       *string
	password      *string
	name          *string
	roles         *[]string
	appendroles   []string
	groups        *[]string
	appendgroups  []string
	email         *string
	alarmURL      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *UserMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAccount sets the "account" field.
func (m *UserMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetRoles sets the "roles" field.
func (m *UserMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *UserMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *UserMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *UserMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ClearRoles clears the value of the "roles" field.
func (m *UserMutation) ClearRoles() {
	m.roles = nil
	m.appendroles = nil
	m.clearedFields[user.FieldRoles] = struct{}{}
}

// RolesCleared returns if the "roles" field was cleared in this mutation.
func (m *UserMutation) RolesCleared() bool {
	_, ok := m.clearedFields[user.FieldRoles]
	return ok
}

// ResetRoles resets all changes to the "roles" field.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
	delete(m.clearedFields, user.FieldRoles)
}

// SetGroups sets the "groups" field.
func (m *UserMutation) SetGroups(s []string) {
	m.groups = &s
	m.appendgroups = nil
}

// Groups returns the value of the "groups" field in the mutation.
func (m *UserMutation) Groups() (r []string, exists bool) {
	v := m.groups
	if v == nil {
		return
	}
	return *v, true
}

// OldGroups returns the old "groups" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroups: %w", err)
	}
	return oldValue.Groups, nil
}

// AppendGroups adds s to the "groups" field.
func (m *UserMutation) AppendGroups(s []string) {
	m.appendgroups = append(m.appendgroups, s...)
}

// AppendedGroups returns the list of values that were appended to the "groups" field in this mutation.
func (m *UserMutation) AppendedGroups() ([]string, bool) {
	if len(m.appendgroups) == 0 {
		return nil, false
	}
	return m.appendgroups, true
}

// ClearGroups clears the value of the "groups" field.
func (m *UserMutation) ClearGroups() {
	m.groups = nil
	m.appendgroups = nil
	m.clearedFields[user.FieldGroups] = struct{}{}
}

// GroupsCleared returns if the "groups" field was cleared in this mutation.
func (m *UserMutation) GroupsCleared() bool {
	_, ok := m.clearedFields[user.FieldGroups]
	return ok
}

// ResetGroups resets all changes to the "groups" field.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.appendgroups = nil
	delete(m.clearedFields, user.FieldGroups)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetAlarmURL sets the "alarmURL" field.
func (m *UserMutation) SetAlarmURL(s string) {
	m.alarmURL = &s
}

// AlarmURL returns the value of the "alarmURL" field in the mutation.
func (m *UserMutation) AlarmURL() (r string, exists bool) {
	v := m.alarmURL
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmURL returns the old "alarmURL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAlarmURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmURL: %w", err)
	}
	return oldValue.AlarmURL, nil
}

// ClearAlarmURL clears the value of the "alarmURL" field.
func (m *UserMutation) ClearAlarmURL() {
	m.alarmURL = nil
	m.clearedFields[user.FieldAlarmURL] = struct{}{}
}

// AlarmURLCleared returns if the "alarmURL" field was cleared in this mutation.
func (m *UserMutation) AlarmURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAlarmURL]
	return ok
}

// ResetAlarmURL resets all changes to the "alarmURL" field.
func (m *UserMutation) ResetAlarmURL() {
	m.alarmURL = nil
	delete(m.clearedFields, user.FieldAlarmURL)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.account != nil {
		fields = append(fields, user.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.roles != nil {
		fields = append(fields, user.FieldRoles)
	}
	if m.groups != nil {
		fields = append(fields, user.FieldGroups)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.alarmURL != nil {
		fields = append(fields, user.FieldAlarmURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldAccount:
		return m.Account()
	case user.FieldPassword:
		return m.Password()
	case user.FieldName:
		return m.Name()
	case user.FieldRoles:
		return m.Roles()
	case user.FieldGroups:
		return m.Groups()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAlarmURL:
		return m.AlarmURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldAccount:
		return m.OldAccount(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldRoles:
		return m.OldRoles(ctx)
	case user.FieldGroups:
		return m.OldGroups(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAlarmURL:
		return m.OldAlarmURL(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	case user.FieldGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroups(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAlarmURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmURL(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldRoles) {
		fields = append(fields, user.FieldRoles)
	}
	if m.FieldCleared(user.FieldGroups) {
		fields = append(fields, user.FieldGroups)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldAlarmURL) {
		fields = append(fields, user.FieldAlarmURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldRoles:
		m.ClearRoles()
		return nil
	case user.FieldGroups:
		m.ClearGroups()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldAlarmURL:
		m.ClearAlarmURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldAccount:
		m.ResetAccount()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldRoles:
		m.ResetRoles()
		return nil
	case user.FieldGroups:
		m.ResetGroups()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAlarmURL:
		m.ResetAlarmURL()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserLoginMutation represents an operation that mutates the UserLogin nodes in the graph.
type UserLoginMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	account         *string
	user_agent      *string
	ip              *string
	track_id        *string
	session_id      *string
	x_forwarded_for *string
	country         *string
	province        *string
	city            *string
	isp             *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UserLogin, error)
	predicates      []predicate.UserLogin
}

var _ ent.Mutation = (*UserLoginMutation)(nil)

// userloginOption allows management of the mutation configuration using functional options.
type userloginOption func(*UserLoginMutation)

// newUserLoginMutation creates new mutation for the UserLogin entity.
func newUserLoginMutation(c config, op Op, opts ...userloginOption) *UserLoginMutation {
	m := &UserLoginMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginID sets the ID field of the mutation.
func withUserLoginID(id int) userloginOption {
	return func(m *UserLoginMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLogin
		)
		m.oldValue = func(ctx context.Context) (*UserLogin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLogin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLogin sets the old UserLogin of the mutation.
func withUserLogin(node *UserLogin) userloginOption {
	return func(m *UserLoginMutation) {
		m.oldValue = func(context.Context) (*UserLogin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLogin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAccount sets the "account" field.
func (m *UserLoginMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserLoginMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserLoginMutation) ResetAccount() {
	m.account = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *UserLoginMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserLoginMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserLoginMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[userlogin.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserLoginMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserLoginMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, userlogin.FieldUserAgent)
}

// SetIP sets the "ip" field.
func (m *UserLoginMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserLoginMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *UserLoginMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[userlogin.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *UserLoginMutation) IPCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *UserLoginMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, userlogin.FieldIP)
}

// SetTrackID sets the "track_id" field.
func (m *UserLoginMutation) SetTrackID(s string) {
	m.track_id = &s
}

// TrackID returns the value of the "track_id" field in the mutation.
func (m *UserLoginMutation) TrackID() (r string, exists bool) {
	v := m.track_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackID returns the old "track_id" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldTrackID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackID: %w", err)
	}
	return oldValue.TrackID, nil
}

// ClearTrackID clears the value of the "track_id" field.
func (m *UserLoginMutation) ClearTrackID() {
	m.track_id = nil
	m.clearedFields[userlogin.FieldTrackID] = struct{}{}
}

// TrackIDCleared returns if the "track_id" field was cleared in this mutation.
func (m *UserLoginMutation) TrackIDCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldTrackID]
	return ok
}

// ResetTrackID resets all changes to the "track_id" field.
func (m *UserLoginMutation) ResetTrackID() {
	m.track_id = nil
	delete(m.clearedFields, userlogin.FieldTrackID)
}

// SetSessionID sets the "session_id" field.
func (m *UserLoginMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *UserLoginMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *UserLoginMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[userlogin.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *UserLoginMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *UserLoginMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, userlogin.FieldSessionID)
}

// SetXForwardedFor sets the "x_forwarded_for" field.
func (m *UserLoginMutation) SetXForwardedFor(s string) {
	m.x_forwarded_for = &s
}

// XForwardedFor returns the value of the "x_forwarded_for" field in the mutation.
func (m *UserLoginMutation) XForwardedFor() (r string, exists bool) {
	v := m.x_forwarded_for
	if v == nil {
		return
	}
	return *v, true
}

// OldXForwardedFor returns the old "x_forwarded_for" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldXForwardedFor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXForwardedFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXForwardedFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXForwardedFor: %w", err)
	}
	return oldValue.XForwardedFor, nil
}

// ClearXForwardedFor clears the value of the "x_forwarded_for" field.
func (m *UserLoginMutation) ClearXForwardedFor() {
	m.x_forwarded_for = nil
	m.clearedFields[userlogin.FieldXForwardedFor] = struct{}{}
}

// XForwardedForCleared returns if the "x_forwarded_for" field was cleared in this mutation.
func (m *UserLoginMutation) XForwardedForCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldXForwardedFor]
	return ok
}

// ResetXForwardedFor resets all changes to the "x_forwarded_for" field.
func (m *UserLoginMutation) ResetXForwardedFor() {
	m.x_forwarded_for = nil
	delete(m.clearedFields, userlogin.FieldXForwardedFor)
}

// SetCountry sets the "country" field.
func (m *UserLoginMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserLoginMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *UserLoginMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[userlogin.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *UserLoginMutation) CountryCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *UserLoginMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, userlogin.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *UserLoginMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserLoginMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *UserLoginMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[userlogin.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *UserLoginMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *UserLoginMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, userlogin.FieldProvince)
}

// SetCity sets the "city" field.
func (m *UserLoginMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLoginMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *UserLoginMutation) ClearCity() {
	m.city = nil
	m.clearedFields[userlogin.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *UserLoginMutation) CityCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *UserLoginMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, userlogin.FieldCity)
}

// SetIsp sets the "isp" field.
func (m *UserLoginMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *UserLoginMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *UserLoginMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[userlogin.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *UserLoginMutation) IspCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *UserLoginMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, userlogin.FieldIsp)
}

// Where appends a list predicates to the UserLoginMutation builder.
func (m *UserLoginMutation) Where(ps ...predicate.UserLogin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserLoginMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLogin).
func (m *UserLoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, userlogin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userlogin.FieldUpdatedAt)
	}
	if m.account != nil {
		fields = append(fields, userlogin.FieldAccount)
	}
	if m.user_agent != nil {
		fields = append(fields, userlogin.FieldUserAgent)
	}
	if m.ip != nil {
		fields = append(fields, userlogin.FieldIP)
	}
	if m.track_id != nil {
		fields = append(fields, userlogin.FieldTrackID)
	}
	if m.session_id != nil {
		fields = append(fields, userlogin.FieldSessionID)
	}
	if m.x_forwarded_for != nil {
		fields = append(fields, userlogin.FieldXForwardedFor)
	}
	if m.country != nil {
		fields = append(fields, userlogin.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, userlogin.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, userlogin.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, userlogin.FieldIsp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlogin.FieldCreatedAt:
		return m.CreatedAt()
	case userlogin.FieldUpdatedAt:
		return m.UpdatedAt()
	case userlogin.FieldAccount:
		return m.Account()
	case userlogin.FieldUserAgent:
		return m.UserAgent()
	case userlogin.FieldIP:
		return m.IP()
	case userlogin.FieldTrackID:
		return m.TrackID()
	case userlogin.FieldSessionID:
		return m.SessionID()
	case userlogin.FieldXForwardedFor:
		return m.XForwardedFor()
	case userlogin.FieldCountry:
		return m.Country()
	case userlogin.FieldProvince:
		return m.Province()
	case userlogin.FieldCity:
		return m.City()
	case userlogin.FieldIsp:
		return m.Isp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlogin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userlogin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userlogin.FieldAccount:
		return m.OldAccount(ctx)
	case userlogin.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case userlogin.FieldIP:
		return m.OldIP(ctx)
	case userlogin.FieldTrackID:
		return m.OldTrackID(ctx)
	case userlogin.FieldSessionID:
		return m.OldSessionID(ctx)
	case userlogin.FieldXForwardedFor:
		return m.OldXForwardedFor(ctx)
	case userlogin.FieldCountry:
		return m.OldCountry(ctx)
	case userlogin.FieldProvince:
		return m.OldProvince(ctx)
	case userlogin.FieldCity:
		return m.OldCity(ctx)
	case userlogin.FieldIsp:
		return m.OldIsp(ctx)
	}
	return nil, fmt.Errorf("unknown UserLogin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlogin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userlogin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userlogin.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case userlogin.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case userlogin.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case userlogin.FieldTrackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackID(v)
		return nil
	case userlogin.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case userlogin.FieldXForwardedFor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXForwardedFor(v)
		return nil
	case userlogin.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case userlogin.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userlogin.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userlogin.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLogin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userlogin.FieldUserAgent) {
		fields = append(fields, userlogin.FieldUserAgent)
	}
	if m.FieldCleared(userlogin.FieldIP) {
		fields = append(fields, userlogin.FieldIP)
	}
	if m.FieldCleared(userlogin.FieldTrackID) {
		fields = append(fields, userlogin.FieldTrackID)
	}
	if m.FieldCleared(userlogin.FieldSessionID) {
		fields = append(fields, userlogin.FieldSessionID)
	}
	if m.FieldCleared(userlogin.FieldXForwardedFor) {
		fields = append(fields, userlogin.FieldXForwardedFor)
	}
	if m.FieldCleared(userlogin.FieldCountry) {
		fields = append(fields, userlogin.FieldCountry)
	}
	if m.FieldCleared(userlogin.FieldProvince) {
		fields = append(fields, userlogin.FieldProvince)
	}
	if m.FieldCleared(userlogin.FieldCity) {
		fields = append(fields, userlogin.FieldCity)
	}
	if m.FieldCleared(userlogin.FieldIsp) {
		fields = append(fields, userlogin.FieldIsp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginMutation) ClearField(name string) error {
	switch name {
	case userlogin.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case userlogin.FieldIP:
		m.ClearIP()
		return nil
	case userlogin.FieldTrackID:
		m.ClearTrackID()
		return nil
	case userlogin.FieldSessionID:
		m.ClearSessionID()
		return nil
	case userlogin.FieldXForwardedFor:
		m.ClearXForwardedFor()
		return nil
	case userlogin.FieldCountry:
		m.ClearCountry()
		return nil
	case userlogin.FieldProvince:
		m.ClearProvince()
		return nil
	case userlogin.FieldCity:
		m.ClearCity()
		return nil
	case userlogin.FieldIsp:
		m.ClearIsp()
		return nil
	}
	return fmt.Errorf("unknown UserLogin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginMutation) ResetField(name string) error {
	switch name {
	case userlogin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userlogin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userlogin.FieldAccount:
		m.ResetAccount()
		return nil
	case userlogin.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case userlogin.FieldIP:
		m.ResetIP()
		return nil
	case userlogin.FieldTrackID:
		m.ResetTrackID()
		return nil
	case userlogin.FieldSessionID:
		m.ResetSessionID()
		return nil
	case userlogin.FieldXForwardedFor:
		m.ResetXForwardedFor()
		return nil
	case userlogin.FieldCountry:
		m.ResetCountry()
		return nil
	case userlogin.FieldProvince:
		m.ResetProvince()
		return nil
	case userlogin.FieldCity:
		m.ResetCity()
		return nil
	case userlogin.FieldIsp:
		m.ResetIsp()
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserLogin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserLogin edge %s", name)
}
