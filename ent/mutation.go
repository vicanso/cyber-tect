// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/vicanso/cybertect/ent/configuration"
	"github.com/vicanso/cybertect/ent/dnsdetector"
	"github.com/vicanso/cybertect/ent/dnsdetectorresult"
	"github.com/vicanso/cybertect/ent/httpdetector"
	"github.com/vicanso/cybertect/ent/httpdetectorresult"
	"github.com/vicanso/cybertect/ent/pingdetector"
	"github.com/vicanso/cybertect/ent/pingdetectorresult"
	"github.com/vicanso/cybertect/ent/predicate"
	"github.com/vicanso/cybertect/ent/schema"
	"github.com/vicanso/cybertect/ent/tcpdetector"
	"github.com/vicanso/cybertect/ent/tcpdetectorresult"
	"github.com/vicanso/cybertect/ent/user"
	"github.com/vicanso/cybertect/ent/userlogin"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConfiguration      = "Configuration"
	TypeDNSDetector        = "DNSDetector"
	TypeDNSDetectorResult  = "DNSDetectorResult"
	TypeHTTPDetector       = "HTTPDetector"
	TypeHTTPDetectorResult = "HTTPDetectorResult"
	TypePingDetector       = "PingDetector"
	TypePingDetectorResult = "PingDetectorResult"
	TypeTCPDetector        = "TCPDetector"
	TypeTCPDetectorResult  = "TCPDetectorResult"
	TypeUser               = "User"
	TypeUserLogin          = "UserLogin"
)

// ConfigurationMutation represents an operation that mutates the Configuration nodes in the graph.
type ConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	category      *configuration.Category
	owner         *string
	data          *string
	started_at    *time.Time
	ended_at      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Configuration, error)
	predicates    []predicate.Configuration
}

var _ ent.Mutation = (*ConfigurationMutation)(nil)

// configurationOption allows management of the mutation configuration using functional options.
type configurationOption func(*ConfigurationMutation)

// newConfigurationMutation creates new mutation for the Configuration entity.
func newConfigurationMutation(c config, op Op, opts ...configurationOption) *ConfigurationMutation {
	m := &ConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationID sets the ID field of the mutation.
func withConfigurationID(id int) configurationOption {
	return func(m *ConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configuration
		)
		m.oldValue = func(ctx context.Context) (*Configuration, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfiguration sets the old Configuration of the mutation.
func withConfiguration(node *Configuration) configurationOption {
	return func(m *ConfigurationMutation) {
		m.oldValue = func(context.Context) (*Configuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConfigurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ConfigurationMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ConfigurationMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *ConfigurationMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ConfigurationMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ConfigurationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *ConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *ConfigurationMutation) SetCategory(c configuration.Category) {
	m.category = &c
}

// Category returns the value of the "category" field in the mutation.
func (m *ConfigurationMutation) Category() (r configuration.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCategory(ctx context.Context) (v configuration.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConfigurationMutation) ResetCategory() {
	m.category = nil
}

// SetOwner sets the "owner" field.
func (m *ConfigurationMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *ConfigurationMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *ConfigurationMutation) ResetOwner() {
	m.owner = nil
}

// SetData sets the "data" field.
func (m *ConfigurationMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *ConfigurationMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *ConfigurationMutation) ResetData() {
	m.data = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ConfigurationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ConfigurationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ConfigurationMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *ConfigurationMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *ConfigurationMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *ConfigurationMutation) ResetEndedAt() {
	m.ended_at = nil
}

// Op returns the operation name.
func (m *ConfigurationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configuration).
func (m *ConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, configuration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configuration.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, configuration.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, configuration.FieldName)
	}
	if m.category != nil {
		fields = append(fields, configuration.FieldCategory)
	}
	if m.owner != nil {
		fields = append(fields, configuration.FieldOwner)
	}
	if m.data != nil {
		fields = append(fields, configuration.FieldData)
	}
	if m.started_at != nil {
		fields = append(fields, configuration.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, configuration.FieldEndedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.CreatedAt()
	case configuration.FieldUpdatedAt:
		return m.UpdatedAt()
	case configuration.FieldStatus:
		return m.Status()
	case configuration.FieldName:
		return m.Name()
	case configuration.FieldCategory:
		return m.Category()
	case configuration.FieldOwner:
		return m.Owner()
	case configuration.FieldData:
		return m.Data()
	case configuration.FieldStartedAt:
		return m.StartedAt()
	case configuration.FieldEndedAt:
		return m.EndedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configuration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case configuration.FieldStatus:
		return m.OldStatus(ctx)
	case configuration.FieldName:
		return m.OldName(ctx)
	case configuration.FieldCategory:
		return m.OldCategory(ctx)
	case configuration.FieldOwner:
		return m.OldOwner(ctx)
	case configuration.FieldData:
		return m.OldData(ctx)
	case configuration.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case configuration.FieldEndedAt:
		return m.OldEndedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Configuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configuration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case configuration.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case configuration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configuration.FieldCategory:
		v, ok := value.(configuration.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case configuration.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case configuration.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case configuration.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case configuration.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, configuration.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Configuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationMutation) ResetField(name string) error {
	switch name {
	case configuration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configuration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case configuration.FieldStatus:
		m.ResetStatus()
		return nil
	case configuration.FieldName:
		m.ResetName()
		return nil
	case configuration.FieldCategory:
		m.ResetCategory()
		return nil
	case configuration.FieldOwner:
		m.ResetOwner()
		return nil
	case configuration.FieldData:
		m.ResetData()
		return nil
	case configuration.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case configuration.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configuration edge %s", name)
}

// DNSDetectorMutation represents an operation that mutates the DNSDetector nodes in the graph.
type DNSDetectorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	owner         *string
	description   *string
	receivers     *[]string
	timeout       *string
	host          *string
	ips           *[]string
	servers       *[]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DNSDetector, error)
	predicates    []predicate.DNSDetector
}

var _ ent.Mutation = (*DNSDetectorMutation)(nil)

// dnsdetectorOption allows management of the mutation configuration using functional options.
type dnsdetectorOption func(*DNSDetectorMutation)

// newDNSDetectorMutation creates new mutation for the DNSDetector entity.
func newDNSDetectorMutation(c config, op Op, opts ...dnsdetectorOption) *DNSDetectorMutation {
	m := &DNSDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSDetectorID sets the ID field of the mutation.
func withDNSDetectorID(id int) dnsdetectorOption {
	return func(m *DNSDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSDetector
		)
		m.oldValue = func(ctx context.Context) (*DNSDetector, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSDetector sets the old DNSDetector of the mutation.
func withDNSDetector(node *DNSDetector) dnsdetectorOption {
	return func(m *DNSDetectorMutation) {
		m.oldValue = func(context.Context) (*DNSDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DNSDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DNSDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DNSDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DNSDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DNSDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DNSDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DNSDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DNSDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DNSDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *DNSDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DNSDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DNSDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *DNSDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwner sets the "owner" field.
func (m *DNSDetectorMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *DNSDetectorMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *DNSDetectorMutation) ResetOwner() {
	m.owner = nil
}

// SetDescription sets the "description" field.
func (m *DNSDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DNSDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DNSDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetReceivers sets the "receivers" field.
func (m *DNSDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *DNSDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *DNSDetectorMutation) ResetReceivers() {
	m.receivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *DNSDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *DNSDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *DNSDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetHost sets the "host" field.
func (m *DNSDetectorMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *DNSDetectorMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *DNSDetectorMutation) ResetHost() {
	m.host = nil
}

// SetIps sets the "ips" field.
func (m *DNSDetectorMutation) SetIps(s []string) {
	m.ips = &s
}

// Ips returns the value of the "ips" field in the mutation.
func (m *DNSDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// ResetIps resets all changes to the "ips" field.
func (m *DNSDetectorMutation) ResetIps() {
	m.ips = nil
}

// SetServers sets the "servers" field.
func (m *DNSDetectorMutation) SetServers(s []string) {
	m.servers = &s
}

// Servers returns the value of the "servers" field in the mutation.
func (m *DNSDetectorMutation) Servers() (r []string, exists bool) {
	v := m.servers
	if v == nil {
		return
	}
	return *v, true
}

// OldServers returns the old "servers" field's value of the DNSDetector entity.
// If the DNSDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorMutation) OldServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServers: %w", err)
	}
	return oldValue.Servers, nil
}

// ResetServers resets all changes to the "servers" field.
func (m *DNSDetectorMutation) ResetServers() {
	m.servers = nil
}

// Op returns the operation name.
func (m *DNSDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSDetector).
func (m *DNSDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSDetectorMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dnsdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dnsdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, dnsdetector.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, dnsdetector.FieldOwner)
	}
	if m.description != nil {
		fields = append(fields, dnsdetector.FieldDescription)
	}
	if m.receivers != nil {
		fields = append(fields, dnsdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, dnsdetector.FieldTimeout)
	}
	if m.host != nil {
		fields = append(fields, dnsdetector.FieldHost)
	}
	if m.ips != nil {
		fields = append(fields, dnsdetector.FieldIps)
	}
	if m.servers != nil {
		fields = append(fields, dnsdetector.FieldServers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsdetector.FieldCreatedAt:
		return m.CreatedAt()
	case dnsdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsdetector.FieldStatus:
		return m.Status()
	case dnsdetector.FieldName:
		return m.Name()
	case dnsdetector.FieldOwner:
		return m.Owner()
	case dnsdetector.FieldDescription:
		return m.Description()
	case dnsdetector.FieldReceivers:
		return m.Receivers()
	case dnsdetector.FieldTimeout:
		return m.Timeout()
	case dnsdetector.FieldHost:
		return m.Host()
	case dnsdetector.FieldIps:
		return m.Ips()
	case dnsdetector.FieldServers:
		return m.Servers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsdetector.FieldStatus:
		return m.OldStatus(ctx)
	case dnsdetector.FieldName:
		return m.OldName(ctx)
	case dnsdetector.FieldOwner:
		return m.OldOwner(ctx)
	case dnsdetector.FieldDescription:
		return m.OldDescription(ctx)
	case dnsdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case dnsdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case dnsdetector.FieldHost:
		return m.OldHost(ctx)
	case dnsdetector.FieldIps:
		return m.OldIps(ctx)
	case dnsdetector.FieldServers:
		return m.OldServers(ctx)
	}
	return nil, fmt.Errorf("unknown DNSDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dnsdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsdetector.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case dnsdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dnsdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case dnsdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case dnsdetector.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case dnsdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case dnsdetector.FieldServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServers(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dnsdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSDetectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSDetectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSDetectorMutation) ResetField(name string) error {
	switch name {
	case dnsdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case dnsdetector.FieldName:
		m.ResetName()
		return nil
	case dnsdetector.FieldOwner:
		m.ResetOwner()
		return nil
	case dnsdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case dnsdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case dnsdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case dnsdetector.FieldHost:
		m.ResetHost()
		return nil
	case dnsdetector.FieldIps:
		m.ResetIps()
		return nil
	case dnsdetector.FieldServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown DNSDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNSDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNSDetector edge %s", name)
}

// DNSDetectorResultMutation represents an operation that mutates the DNSDetectorResult nodes in the graph.
type DNSDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *int8
	addresult      *int8
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	host           *string
	results        *schema.DNSDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DNSDetectorResult, error)
	predicates     []predicate.DNSDetectorResult
}

var _ ent.Mutation = (*DNSDetectorResultMutation)(nil)

// dnsdetectorresultOption allows management of the mutation configuration using functional options.
type dnsdetectorresultOption func(*DNSDetectorResultMutation)

// newDNSDetectorResultMutation creates new mutation for the DNSDetectorResult entity.
func newDNSDetectorResultMutation(c config, op Op, opts ...dnsdetectorresultOption) *DNSDetectorResultMutation {
	m := &DNSDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSDetectorResultID sets the ID field of the mutation.
func withDNSDetectorResultID(id int) dnsdetectorresultOption {
	return func(m *DNSDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*DNSDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSDetectorResult sets the old DNSDetectorResult of the mutation.
func withDNSDetectorResult(node *DNSDetectorResult) dnsdetectorresultOption {
	return func(m *DNSDetectorResultMutation) {
		m.oldValue = func(context.Context) (*DNSDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DNSDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DNSDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DNSDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DNSDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DNSDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DNSDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DNSDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *DNSDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *DNSDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *DNSDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *DNSDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *DNSDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *DNSDetectorResultMutation) SetResult(i int8) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *DNSDetectorResultMutation) Result() (r int8, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldResult(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *DNSDetectorResultMutation) AddResult(i int8) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *DNSDetectorResultMutation) AddedResult() (r int8, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *DNSDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *DNSDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *DNSDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *DNSDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *DNSDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *DNSDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *DNSDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
}

// Messages returns the value of the "messages" field in the mutation.
func (m *DNSDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ResetMessages resets all changes to the "messages" field.
func (m *DNSDetectorResultMutation) ResetMessages() {
	m.messages = nil
}

// SetHost sets the "host" field.
func (m *DNSDetectorResultMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *DNSDetectorResultMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *DNSDetectorResultMutation) ResetHost() {
	m.host = nil
}

// SetResults sets the "results" field.
func (m *DNSDetectorResultMutation) SetResults(sdsr schema.DNSDetectorSubResults) {
	m.results = &sdsr
}

// Results returns the value of the "results" field in the mutation.
func (m *DNSDetectorResultMutation) Results() (r schema.DNSDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the DNSDetectorResult entity.
// If the DNSDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSDetectorResultMutation) OldResults(ctx context.Context) (v schema.DNSDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ResetResults resets all changes to the "results" field.
func (m *DNSDetectorResultMutation) ResetResults() {
	m.results = nil
}

// Op returns the operation name.
func (m *DNSDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSDetectorResult).
func (m *DNSDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dnsdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, dnsdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, dnsdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, dnsdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, dnsdetectorresult.FieldMessages)
	}
	if m.host != nil {
		fields = append(fields, dnsdetectorresult.FieldHost)
	}
	if m.results != nil {
		fields = append(fields, dnsdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case dnsdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsdetectorresult.FieldTask:
		return m.Task()
	case dnsdetectorresult.FieldResult:
		return m.Result()
	case dnsdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case dnsdetectorresult.FieldMessages:
		return m.Messages()
	case dnsdetectorresult.FieldHost:
		return m.Host()
	case dnsdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case dnsdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case dnsdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case dnsdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case dnsdetectorresult.FieldHost:
		return m.OldHost(ctx)
	case dnsdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case dnsdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case dnsdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case dnsdetectorresult.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case dnsdetectorresult.FieldResults:
		v, ok := value.(schema.DNSDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, dnsdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, dnsdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, dnsdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsdetectorresult.FieldTask:
		return m.AddedTask()
	case dnsdetectorresult.FieldResult:
		return m.AddedResult()
	case dnsdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case dnsdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSDetectorResultMutation) ResetField(name string) error {
	switch name {
	case dnsdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case dnsdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case dnsdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case dnsdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case dnsdetectorresult.FieldHost:
		m.ResetHost()
		return nil
	case dnsdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown DNSDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNSDetectorResult edge %s", name)
}

// HTTPDetectorMutation represents an operation that mutates the HTTPDetector nodes in the graph.
type HTTPDetectorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	owner         *string
	description   *string
	receivers     *[]string
	timeout       *string
	ips           *[]string
	url           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HTTPDetector, error)
	predicates    []predicate.HTTPDetector
}

var _ ent.Mutation = (*HTTPDetectorMutation)(nil)

// httpdetectorOption allows management of the mutation configuration using functional options.
type httpdetectorOption func(*HTTPDetectorMutation)

// newHTTPDetectorMutation creates new mutation for the HTTPDetector entity.
func newHTTPDetectorMutation(c config, op Op, opts ...httpdetectorOption) *HTTPDetectorMutation {
	m := &HTTPDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeHTTPDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHTTPDetectorID sets the ID field of the mutation.
func withHTTPDetectorID(id int) httpdetectorOption {
	return func(m *HTTPDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *HTTPDetector
		)
		m.oldValue = func(ctx context.Context) (*HTTPDetector, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HTTPDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHTTPDetector sets the old HTTPDetector of the mutation.
func withHTTPDetector(node *HTTPDetector) httpdetectorOption {
	return func(m *HTTPDetectorMutation) {
		m.oldValue = func(context.Context) (*HTTPDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HTTPDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HTTPDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HTTPDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *HTTPDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HTTPDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HTTPDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HTTPDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HTTPDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HTTPDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *HTTPDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *HTTPDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *HTTPDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *HTTPDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *HTTPDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *HTTPDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HTTPDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HTTPDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwner sets the "owner" field.
func (m *HTTPDetectorMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *HTTPDetectorMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *HTTPDetectorMutation) ResetOwner() {
	m.owner = nil
}

// SetDescription sets the "description" field.
func (m *HTTPDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HTTPDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HTTPDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetReceivers sets the "receivers" field.
func (m *HTTPDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *HTTPDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *HTTPDetectorMutation) ResetReceivers() {
	m.receivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *HTTPDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *HTTPDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *HTTPDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetIps sets the "ips" field.
func (m *HTTPDetectorMutation) SetIps(s []string) {
	m.ips = &s
}

// Ips returns the value of the "ips" field in the mutation.
func (m *HTTPDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// ResetIps resets all changes to the "ips" field.
func (m *HTTPDetectorMutation) ResetIps() {
	m.ips = nil
}

// SetURL sets the "url" field.
func (m *HTTPDetectorMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *HTTPDetectorMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the HTTPDetector entity.
// If the HTTPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *HTTPDetectorMutation) ResetURL() {
	m.url = nil
}

// Op returns the operation name.
func (m *HTTPDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HTTPDetector).
func (m *HTTPDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HTTPDetectorMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, httpdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, httpdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, httpdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, httpdetector.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, httpdetector.FieldOwner)
	}
	if m.description != nil {
		fields = append(fields, httpdetector.FieldDescription)
	}
	if m.receivers != nil {
		fields = append(fields, httpdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, httpdetector.FieldTimeout)
	}
	if m.ips != nil {
		fields = append(fields, httpdetector.FieldIps)
	}
	if m.url != nil {
		fields = append(fields, httpdetector.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HTTPDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case httpdetector.FieldCreatedAt:
		return m.CreatedAt()
	case httpdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case httpdetector.FieldStatus:
		return m.Status()
	case httpdetector.FieldName:
		return m.Name()
	case httpdetector.FieldOwner:
		return m.Owner()
	case httpdetector.FieldDescription:
		return m.Description()
	case httpdetector.FieldReceivers:
		return m.Receivers()
	case httpdetector.FieldTimeout:
		return m.Timeout()
	case httpdetector.FieldIps:
		return m.Ips()
	case httpdetector.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HTTPDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case httpdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case httpdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case httpdetector.FieldStatus:
		return m.OldStatus(ctx)
	case httpdetector.FieldName:
		return m.OldName(ctx)
	case httpdetector.FieldOwner:
		return m.OldOwner(ctx)
	case httpdetector.FieldDescription:
		return m.OldDescription(ctx)
	case httpdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case httpdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case httpdetector.FieldIps:
		return m.OldIps(ctx)
	case httpdetector.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown HTTPDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case httpdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case httpdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case httpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case httpdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case httpdetector.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case httpdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case httpdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case httpdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case httpdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case httpdetector.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HTTPDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, httpdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HTTPDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case httpdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case httpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HTTPDetectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HTTPDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HTTPDetectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HTTPDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HTTPDetectorMutation) ResetField(name string) error {
	switch name {
	case httpdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case httpdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case httpdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case httpdetector.FieldName:
		m.ResetName()
		return nil
	case httpdetector.FieldOwner:
		m.ResetOwner()
		return nil
	case httpdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case httpdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case httpdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case httpdetector.FieldIps:
		m.ResetIps()
		return nil
	case httpdetector.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown HTTPDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HTTPDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HTTPDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HTTPDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HTTPDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HTTPDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HTTPDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HTTPDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HTTPDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetector edge %s", name)
}

// HTTPDetectorResultMutation represents an operation that mutates the HTTPDetectorResult nodes in the graph.
type HTTPDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *int8
	addresult      *int8
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	url            *string
	results        *schema.HTTPDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*HTTPDetectorResult, error)
	predicates     []predicate.HTTPDetectorResult
}

var _ ent.Mutation = (*HTTPDetectorResultMutation)(nil)

// httpdetectorresultOption allows management of the mutation configuration using functional options.
type httpdetectorresultOption func(*HTTPDetectorResultMutation)

// newHTTPDetectorResultMutation creates new mutation for the HTTPDetectorResult entity.
func newHTTPDetectorResultMutation(c config, op Op, opts ...httpdetectorresultOption) *HTTPDetectorResultMutation {
	m := &HTTPDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeHTTPDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHTTPDetectorResultID sets the ID field of the mutation.
func withHTTPDetectorResultID(id int) httpdetectorresultOption {
	return func(m *HTTPDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *HTTPDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*HTTPDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HTTPDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHTTPDetectorResult sets the old HTTPDetectorResult of the mutation.
func withHTTPDetectorResult(node *HTTPDetectorResult) httpdetectorresultOption {
	return func(m *HTTPDetectorResultMutation) {
		m.oldValue = func(context.Context) (*HTTPDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HTTPDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HTTPDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HTTPDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *HTTPDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HTTPDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HTTPDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HTTPDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HTTPDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HTTPDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *HTTPDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *HTTPDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *HTTPDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *HTTPDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *HTTPDetectorResultMutation) SetResult(i int8) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *HTTPDetectorResultMutation) Result() (r int8, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldResult(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *HTTPDetectorResultMutation) AddResult(i int8) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedResult() (r int8, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *HTTPDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *HTTPDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *HTTPDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *HTTPDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *HTTPDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *HTTPDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *HTTPDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
}

// Messages returns the value of the "messages" field in the mutation.
func (m *HTTPDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ResetMessages resets all changes to the "messages" field.
func (m *HTTPDetectorResultMutation) ResetMessages() {
	m.messages = nil
}

// SetURL sets the "url" field.
func (m *HTTPDetectorResultMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *HTTPDetectorResultMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *HTTPDetectorResultMutation) ResetURL() {
	m.url = nil
}

// SetResults sets the "results" field.
func (m *HTTPDetectorResultMutation) SetResults(sdsr schema.HTTPDetectorSubResults) {
	m.results = &sdsr
}

// Results returns the value of the "results" field in the mutation.
func (m *HTTPDetectorResultMutation) Results() (r schema.HTTPDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the HTTPDetectorResult entity.
// If the HTTPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HTTPDetectorResultMutation) OldResults(ctx context.Context) (v schema.HTTPDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ResetResults resets all changes to the "results" field.
func (m *HTTPDetectorResultMutation) ResetResults() {
	m.results = nil
}

// Op returns the operation name.
func (m *HTTPDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HTTPDetectorResult).
func (m *HTTPDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HTTPDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, httpdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, httpdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, httpdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, httpdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, httpdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, httpdetectorresult.FieldMessages)
	}
	if m.url != nil {
		fields = append(fields, httpdetectorresult.FieldURL)
	}
	if m.results != nil {
		fields = append(fields, httpdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HTTPDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case httpdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case httpdetectorresult.FieldTask:
		return m.Task()
	case httpdetectorresult.FieldResult:
		return m.Result()
	case httpdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case httpdetectorresult.FieldMessages:
		return m.Messages()
	case httpdetectorresult.FieldURL:
		return m.URL()
	case httpdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HTTPDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case httpdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case httpdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case httpdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case httpdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case httpdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case httpdetectorresult.FieldURL:
		return m.OldURL(ctx)
	case httpdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case httpdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case httpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case httpdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case httpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case httpdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case httpdetectorresult.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case httpdetectorresult.FieldResults:
		v, ok := value.(schema.HTTPDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HTTPDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, httpdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, httpdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, httpdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HTTPDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case httpdetectorresult.FieldTask:
		return m.AddedTask()
	case httpdetectorresult.FieldResult:
		return m.AddedResult()
	case httpdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HTTPDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case httpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case httpdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case httpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HTTPDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HTTPDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HTTPDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HTTPDetectorResultMutation) ResetField(name string) error {
	switch name {
	case httpdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case httpdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case httpdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case httpdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case httpdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case httpdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case httpdetectorresult.FieldURL:
		m.ResetURL()
		return nil
	case httpdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown HTTPDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HTTPDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HTTPDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HTTPDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HTTPDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HTTPDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HTTPDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HTTPDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HTTPDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HTTPDetectorResult edge %s", name)
}

// PingDetectorMutation represents an operation that mutates the PingDetector nodes in the graph.
type PingDetectorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	owner         *string
	description   *string
	receivers     *[]string
	timeout       *string
	ips           *[]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PingDetector, error)
	predicates    []predicate.PingDetector
}

var _ ent.Mutation = (*PingDetectorMutation)(nil)

// pingdetectorOption allows management of the mutation configuration using functional options.
type pingdetectorOption func(*PingDetectorMutation)

// newPingDetectorMutation creates new mutation for the PingDetector entity.
func newPingDetectorMutation(c config, op Op, opts ...pingdetectorOption) *PingDetectorMutation {
	m := &PingDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypePingDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPingDetectorID sets the ID field of the mutation.
func withPingDetectorID(id int) pingdetectorOption {
	return func(m *PingDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *PingDetector
		)
		m.oldValue = func(ctx context.Context) (*PingDetector, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PingDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPingDetector sets the old PingDetector of the mutation.
func withPingDetector(node *PingDetector) pingdetectorOption {
	return func(m *PingDetectorMutation) {
		m.oldValue = func(context.Context) (*PingDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PingDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PingDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PingDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PingDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PingDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PingDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PingDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PingDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PingDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PingDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PingDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *PingDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PingDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PingDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *PingDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PingDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PingDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwner sets the "owner" field.
func (m *PingDetectorMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *PingDetectorMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *PingDetectorMutation) ResetOwner() {
	m.owner = nil
}

// SetDescription sets the "description" field.
func (m *PingDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PingDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PingDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetReceivers sets the "receivers" field.
func (m *PingDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *PingDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *PingDetectorMutation) ResetReceivers() {
	m.receivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *PingDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *PingDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *PingDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetIps sets the "ips" field.
func (m *PingDetectorMutation) SetIps(s []string) {
	m.ips = &s
}

// Ips returns the value of the "ips" field in the mutation.
func (m *PingDetectorMutation) Ips() (r []string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the PingDetector entity.
// If the PingDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorMutation) OldIps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// ResetIps resets all changes to the "ips" field.
func (m *PingDetectorMutation) ResetIps() {
	m.ips = nil
}

// Op returns the operation name.
func (m *PingDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PingDetector).
func (m *PingDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PingDetectorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, pingdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pingdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, pingdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, pingdetector.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, pingdetector.FieldOwner)
	}
	if m.description != nil {
		fields = append(fields, pingdetector.FieldDescription)
	}
	if m.receivers != nil {
		fields = append(fields, pingdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, pingdetector.FieldTimeout)
	}
	if m.ips != nil {
		fields = append(fields, pingdetector.FieldIps)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PingDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pingdetector.FieldCreatedAt:
		return m.CreatedAt()
	case pingdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case pingdetector.FieldStatus:
		return m.Status()
	case pingdetector.FieldName:
		return m.Name()
	case pingdetector.FieldOwner:
		return m.Owner()
	case pingdetector.FieldDescription:
		return m.Description()
	case pingdetector.FieldReceivers:
		return m.Receivers()
	case pingdetector.FieldTimeout:
		return m.Timeout()
	case pingdetector.FieldIps:
		return m.Ips()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PingDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pingdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pingdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pingdetector.FieldStatus:
		return m.OldStatus(ctx)
	case pingdetector.FieldName:
		return m.OldName(ctx)
	case pingdetector.FieldOwner:
		return m.OldOwner(ctx)
	case pingdetector.FieldDescription:
		return m.OldDescription(ctx)
	case pingdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case pingdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case pingdetector.FieldIps:
		return m.OldIps(ctx)
	}
	return nil, fmt.Errorf("unknown PingDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pingdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pingdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pingdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pingdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pingdetector.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case pingdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case pingdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case pingdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case pingdetector.FieldIps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PingDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, pingdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PingDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pingdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pingdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PingDetectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PingDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PingDetectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PingDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PingDetectorMutation) ResetField(name string) error {
	switch name {
	case pingdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pingdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pingdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case pingdetector.FieldName:
		m.ResetName()
		return nil
	case pingdetector.FieldOwner:
		m.ResetOwner()
		return nil
	case pingdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case pingdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case pingdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case pingdetector.FieldIps:
		m.ResetIps()
		return nil
	}
	return fmt.Errorf("unknown PingDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PingDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PingDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PingDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PingDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PingDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PingDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PingDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PingDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PingDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PingDetector edge %s", name)
}

// PingDetectorResultMutation represents an operation that mutates the PingDetectorResult nodes in the graph.
type PingDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *int8
	addresult      *int8
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	ips            *string
	results        *schema.PingDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PingDetectorResult, error)
	predicates     []predicate.PingDetectorResult
}

var _ ent.Mutation = (*PingDetectorResultMutation)(nil)

// pingdetectorresultOption allows management of the mutation configuration using functional options.
type pingdetectorresultOption func(*PingDetectorResultMutation)

// newPingDetectorResultMutation creates new mutation for the PingDetectorResult entity.
func newPingDetectorResultMutation(c config, op Op, opts ...pingdetectorresultOption) *PingDetectorResultMutation {
	m := &PingDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypePingDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPingDetectorResultID sets the ID field of the mutation.
func withPingDetectorResultID(id int) pingdetectorresultOption {
	return func(m *PingDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *PingDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*PingDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PingDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPingDetectorResult sets the old PingDetectorResult of the mutation.
func withPingDetectorResult(node *PingDetectorResult) pingdetectorresultOption {
	return func(m *PingDetectorResultMutation) {
		m.oldValue = func(context.Context) (*PingDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PingDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PingDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PingDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PingDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PingDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PingDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PingDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PingDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PingDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *PingDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *PingDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *PingDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *PingDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *PingDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *PingDetectorResultMutation) SetResult(i int8) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *PingDetectorResultMutation) Result() (r int8, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldResult(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *PingDetectorResultMutation) AddResult(i int8) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *PingDetectorResultMutation) AddedResult() (r int8, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *PingDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *PingDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *PingDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *PingDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *PingDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *PingDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *PingDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
}

// Messages returns the value of the "messages" field in the mutation.
func (m *PingDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ResetMessages resets all changes to the "messages" field.
func (m *PingDetectorResultMutation) ResetMessages() {
	m.messages = nil
}

// SetIps sets the "ips" field.
func (m *PingDetectorResultMutation) SetIps(s string) {
	m.ips = &s
}

// Ips returns the value of the "ips" field in the mutation.
func (m *PingDetectorResultMutation) Ips() (r string, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldIps(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// ResetIps resets all changes to the "ips" field.
func (m *PingDetectorResultMutation) ResetIps() {
	m.ips = nil
}

// SetResults sets the "results" field.
func (m *PingDetectorResultMutation) SetResults(sdsr schema.PingDetectorSubResults) {
	m.results = &sdsr
}

// Results returns the value of the "results" field in the mutation.
func (m *PingDetectorResultMutation) Results() (r schema.PingDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the PingDetectorResult entity.
// If the PingDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PingDetectorResultMutation) OldResults(ctx context.Context) (v schema.PingDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ResetResults resets all changes to the "results" field.
func (m *PingDetectorResultMutation) ResetResults() {
	m.results = nil
}

// Op returns the operation name.
func (m *PingDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PingDetectorResult).
func (m *PingDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PingDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, pingdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pingdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, pingdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, pingdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, pingdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, pingdetectorresult.FieldMessages)
	}
	if m.ips != nil {
		fields = append(fields, pingdetectorresult.FieldIps)
	}
	if m.results != nil {
		fields = append(fields, pingdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PingDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case pingdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case pingdetectorresult.FieldTask:
		return m.Task()
	case pingdetectorresult.FieldResult:
		return m.Result()
	case pingdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case pingdetectorresult.FieldMessages:
		return m.Messages()
	case pingdetectorresult.FieldIps:
		return m.Ips()
	case pingdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PingDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pingdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pingdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case pingdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case pingdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case pingdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case pingdetectorresult.FieldIps:
		return m.OldIps(ctx)
	case pingdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pingdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pingdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case pingdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case pingdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case pingdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case pingdetectorresult.FieldIps:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case pingdetectorresult.FieldResults:
		v, ok := value.(schema.PingDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PingDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, pingdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, pingdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, pingdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PingDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pingdetectorresult.FieldTask:
		return m.AddedTask()
	case pingdetectorresult.FieldResult:
		return m.AddedResult()
	case pingdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PingDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pingdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case pingdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case pingdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PingDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PingDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PingDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PingDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PingDetectorResultMutation) ResetField(name string) error {
	switch name {
	case pingdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pingdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pingdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case pingdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case pingdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case pingdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case pingdetectorresult.FieldIps:
		m.ResetIps()
		return nil
	case pingdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown PingDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PingDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PingDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PingDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PingDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PingDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PingDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PingDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PingDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PingDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PingDetectorResult edge %s", name)
}

// TCPDetectorMutation represents an operation that mutates the TCPDetector nodes in the graph.
type TCPDetectorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	name          *string
	owner         *string
	description   *string
	receivers     *[]string
	timeout       *string
	addrs         *[]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TCPDetector, error)
	predicates    []predicate.TCPDetector
}

var _ ent.Mutation = (*TCPDetectorMutation)(nil)

// tcpdetectorOption allows management of the mutation configuration using functional options.
type tcpdetectorOption func(*TCPDetectorMutation)

// newTCPDetectorMutation creates new mutation for the TCPDetector entity.
func newTCPDetectorMutation(c config, op Op, opts ...tcpdetectorOption) *TCPDetectorMutation {
	m := &TCPDetectorMutation{
		config:        c,
		op:            op,
		typ:           TypeTCPDetector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTCPDetectorID sets the ID field of the mutation.
func withTCPDetectorID(id int) tcpdetectorOption {
	return func(m *TCPDetectorMutation) {
		var (
			err   error
			once  sync.Once
			value *TCPDetector
		)
		m.oldValue = func(ctx context.Context) (*TCPDetector, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TCPDetector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTCPDetector sets the old TCPDetector of the mutation.
func withTCPDetector(node *TCPDetector) tcpdetectorOption {
	return func(m *TCPDetectorMutation) {
		m.oldValue = func(context.Context) (*TCPDetector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TCPDetectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TCPDetectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TCPDetectorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TCPDetectorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TCPDetectorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TCPDetectorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TCPDetectorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TCPDetectorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TCPDetectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TCPDetectorMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TCPDetectorMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *TCPDetectorMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TCPDetectorMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TCPDetectorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *TCPDetectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TCPDetectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TCPDetectorMutation) ResetName() {
	m.name = nil
}

// SetOwner sets the "owner" field.
func (m *TCPDetectorMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *TCPDetectorMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *TCPDetectorMutation) ResetOwner() {
	m.owner = nil
}

// SetDescription sets the "description" field.
func (m *TCPDetectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TCPDetectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TCPDetectorMutation) ResetDescription() {
	m.description = nil
}

// SetReceivers sets the "receivers" field.
func (m *TCPDetectorMutation) SetReceivers(s []string) {
	m.receivers = &s
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *TCPDetectorMutation) Receivers() (r []string, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldReceivers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *TCPDetectorMutation) ResetReceivers() {
	m.receivers = nil
}

// SetTimeout sets the "timeout" field.
func (m *TCPDetectorMutation) SetTimeout(s string) {
	m.timeout = &s
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *TCPDetectorMutation) Timeout() (r string, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *TCPDetectorMutation) ResetTimeout() {
	m.timeout = nil
}

// SetAddrs sets the "addrs" field.
func (m *TCPDetectorMutation) SetAddrs(s []string) {
	m.addrs = &s
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *TCPDetectorMutation) Addrs() (r []string, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the TCPDetector entity.
// If the TCPDetector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorMutation) OldAddrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *TCPDetectorMutation) ResetAddrs() {
	m.addrs = nil
}

// Op returns the operation name.
func (m *TCPDetectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TCPDetector).
func (m *TCPDetectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TCPDetectorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, tcpdetector.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tcpdetector.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tcpdetector.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tcpdetector.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, tcpdetector.FieldOwner)
	}
	if m.description != nil {
		fields = append(fields, tcpdetector.FieldDescription)
	}
	if m.receivers != nil {
		fields = append(fields, tcpdetector.FieldReceivers)
	}
	if m.timeout != nil {
		fields = append(fields, tcpdetector.FieldTimeout)
	}
	if m.addrs != nil {
		fields = append(fields, tcpdetector.FieldAddrs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TCPDetectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tcpdetector.FieldCreatedAt:
		return m.CreatedAt()
	case tcpdetector.FieldUpdatedAt:
		return m.UpdatedAt()
	case tcpdetector.FieldStatus:
		return m.Status()
	case tcpdetector.FieldName:
		return m.Name()
	case tcpdetector.FieldOwner:
		return m.Owner()
	case tcpdetector.FieldDescription:
		return m.Description()
	case tcpdetector.FieldReceivers:
		return m.Receivers()
	case tcpdetector.FieldTimeout:
		return m.Timeout()
	case tcpdetector.FieldAddrs:
		return m.Addrs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TCPDetectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tcpdetector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tcpdetector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tcpdetector.FieldStatus:
		return m.OldStatus(ctx)
	case tcpdetector.FieldName:
		return m.OldName(ctx)
	case tcpdetector.FieldOwner:
		return m.OldOwner(ctx)
	case tcpdetector.FieldDescription:
		return m.OldDescription(ctx)
	case tcpdetector.FieldReceivers:
		return m.OldReceivers(ctx)
	case tcpdetector.FieldTimeout:
		return m.OldTimeout(ctx)
	case tcpdetector.FieldAddrs:
		return m.OldAddrs(ctx)
	}
	return nil, fmt.Errorf("unknown TCPDetector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tcpdetector.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tcpdetector.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tcpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tcpdetector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tcpdetector.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case tcpdetector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tcpdetector.FieldReceivers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case tcpdetector.FieldTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case tcpdetector.FieldAddrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TCPDetectorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tcpdetector.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TCPDetectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tcpdetector.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tcpdetector.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TCPDetectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TCPDetectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TCPDetectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TCPDetector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TCPDetectorMutation) ResetField(name string) error {
	switch name {
	case tcpdetector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tcpdetector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tcpdetector.FieldStatus:
		m.ResetStatus()
		return nil
	case tcpdetector.FieldName:
		m.ResetName()
		return nil
	case tcpdetector.FieldOwner:
		m.ResetOwner()
		return nil
	case tcpdetector.FieldDescription:
		m.ResetDescription()
		return nil
	case tcpdetector.FieldReceivers:
		m.ResetReceivers()
		return nil
	case tcpdetector.FieldTimeout:
		m.ResetTimeout()
		return nil
	case tcpdetector.FieldAddrs:
		m.ResetAddrs()
		return nil
	}
	return fmt.Errorf("unknown TCPDetector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TCPDetectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TCPDetectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TCPDetectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TCPDetectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TCPDetectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TCPDetectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TCPDetectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TCPDetector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TCPDetectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TCPDetector edge %s", name)
}

// TCPDetectorResultMutation represents an operation that mutates the TCPDetectorResult nodes in the graph.
type TCPDetectorResultMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	task           *int
	addtask        *int
	result         *int8
	addresult      *int8
	maxDuration    *int
	addmaxDuration *int
	messages       *[]string
	addrs          *string
	results        *schema.TCPDetectorSubResults
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TCPDetectorResult, error)
	predicates     []predicate.TCPDetectorResult
}

var _ ent.Mutation = (*TCPDetectorResultMutation)(nil)

// tcpdetectorresultOption allows management of the mutation configuration using functional options.
type tcpdetectorresultOption func(*TCPDetectorResultMutation)

// newTCPDetectorResultMutation creates new mutation for the TCPDetectorResult entity.
func newTCPDetectorResultMutation(c config, op Op, opts ...tcpdetectorresultOption) *TCPDetectorResultMutation {
	m := &TCPDetectorResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTCPDetectorResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTCPDetectorResultID sets the ID field of the mutation.
func withTCPDetectorResultID(id int) tcpdetectorresultOption {
	return func(m *TCPDetectorResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TCPDetectorResult
		)
		m.oldValue = func(ctx context.Context) (*TCPDetectorResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TCPDetectorResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTCPDetectorResult sets the old TCPDetectorResult of the mutation.
func withTCPDetectorResult(node *TCPDetectorResult) tcpdetectorresultOption {
	return func(m *TCPDetectorResultMutation) {
		m.oldValue = func(context.Context) (*TCPDetectorResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TCPDetectorResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TCPDetectorResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TCPDetectorResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TCPDetectorResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TCPDetectorResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TCPDetectorResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TCPDetectorResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TCPDetectorResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TCPDetectorResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTask sets the "task" field.
func (m *TCPDetectorResultMutation) SetTask(i int) {
	m.task = &i
	m.addtask = nil
}

// Task returns the value of the "task" field in the mutation.
func (m *TCPDetectorResultMutation) Task() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTask returns the old "task" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldTask(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTask: %w", err)
	}
	return oldValue.Task, nil
}

// AddTask adds i to the "task" field.
func (m *TCPDetectorResultMutation) AddTask(i int) {
	if m.addtask != nil {
		*m.addtask += i
	} else {
		m.addtask = &i
	}
}

// AddedTask returns the value that was added to the "task" field in this mutation.
func (m *TCPDetectorResultMutation) AddedTask() (r int, exists bool) {
	v := m.addtask
	if v == nil {
		return
	}
	return *v, true
}

// ResetTask resets all changes to the "task" field.
func (m *TCPDetectorResultMutation) ResetTask() {
	m.task = nil
	m.addtask = nil
}

// SetResult sets the "result" field.
func (m *TCPDetectorResultMutation) SetResult(i int8) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *TCPDetectorResultMutation) Result() (r int8, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldResult(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *TCPDetectorResultMutation) AddResult(i int8) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *TCPDetectorResultMutation) AddedResult() (r int8, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *TCPDetectorResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetMaxDuration sets the "maxDuration" field.
func (m *TCPDetectorResultMutation) SetMaxDuration(i int) {
	m.maxDuration = &i
	m.addmaxDuration = nil
}

// MaxDuration returns the value of the "maxDuration" field in the mutation.
func (m *TCPDetectorResultMutation) MaxDuration() (r int, exists bool) {
	v := m.maxDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDuration returns the old "maxDuration" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldMaxDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDuration: %w", err)
	}
	return oldValue.MaxDuration, nil
}

// AddMaxDuration adds i to the "maxDuration" field.
func (m *TCPDetectorResultMutation) AddMaxDuration(i int) {
	if m.addmaxDuration != nil {
		*m.addmaxDuration += i
	} else {
		m.addmaxDuration = &i
	}
}

// AddedMaxDuration returns the value that was added to the "maxDuration" field in this mutation.
func (m *TCPDetectorResultMutation) AddedMaxDuration() (r int, exists bool) {
	v := m.addmaxDuration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDuration resets all changes to the "maxDuration" field.
func (m *TCPDetectorResultMutation) ResetMaxDuration() {
	m.maxDuration = nil
	m.addmaxDuration = nil
}

// SetMessages sets the "messages" field.
func (m *TCPDetectorResultMutation) SetMessages(s []string) {
	m.messages = &s
}

// Messages returns the value of the "messages" field in the mutation.
func (m *TCPDetectorResultMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ResetMessages resets all changes to the "messages" field.
func (m *TCPDetectorResultMutation) ResetMessages() {
	m.messages = nil
}

// SetAddrs sets the "addrs" field.
func (m *TCPDetectorResultMutation) SetAddrs(s string) {
	m.addrs = &s
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *TCPDetectorResultMutation) Addrs() (r string, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldAddrs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *TCPDetectorResultMutation) ResetAddrs() {
	m.addrs = nil
}

// SetResults sets the "results" field.
func (m *TCPDetectorResultMutation) SetResults(sdsr schema.TCPDetectorSubResults) {
	m.results = &sdsr
}

// Results returns the value of the "results" field in the mutation.
func (m *TCPDetectorResultMutation) Results() (r schema.TCPDetectorSubResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the TCPDetectorResult entity.
// If the TCPDetectorResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TCPDetectorResultMutation) OldResults(ctx context.Context) (v schema.TCPDetectorSubResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ResetResults resets all changes to the "results" field.
func (m *TCPDetectorResultMutation) ResetResults() {
	m.results = nil
}

// Op returns the operation name.
func (m *TCPDetectorResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TCPDetectorResult).
func (m *TCPDetectorResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TCPDetectorResultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, tcpdetectorresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tcpdetectorresult.FieldUpdatedAt)
	}
	if m.task != nil {
		fields = append(fields, tcpdetectorresult.FieldTask)
	}
	if m.result != nil {
		fields = append(fields, tcpdetectorresult.FieldResult)
	}
	if m.maxDuration != nil {
		fields = append(fields, tcpdetectorresult.FieldMaxDuration)
	}
	if m.messages != nil {
		fields = append(fields, tcpdetectorresult.FieldMessages)
	}
	if m.addrs != nil {
		fields = append(fields, tcpdetectorresult.FieldAddrs)
	}
	if m.results != nil {
		fields = append(fields, tcpdetectorresult.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TCPDetectorResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		return m.CreatedAt()
	case tcpdetectorresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case tcpdetectorresult.FieldTask:
		return m.Task()
	case tcpdetectorresult.FieldResult:
		return m.Result()
	case tcpdetectorresult.FieldMaxDuration:
		return m.MaxDuration()
	case tcpdetectorresult.FieldMessages:
		return m.Messages()
	case tcpdetectorresult.FieldAddrs:
		return m.Addrs()
	case tcpdetectorresult.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TCPDetectorResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tcpdetectorresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tcpdetectorresult.FieldTask:
		return m.OldTask(ctx)
	case tcpdetectorresult.FieldResult:
		return m.OldResult(ctx)
	case tcpdetectorresult.FieldMaxDuration:
		return m.OldMaxDuration(ctx)
	case tcpdetectorresult.FieldMessages:
		return m.OldMessages(ctx)
	case tcpdetectorresult.FieldAddrs:
		return m.OldAddrs(ctx)
	case tcpdetectorresult.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tcpdetectorresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tcpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTask(v)
		return nil
	case tcpdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDuration(v)
		return nil
	case tcpdetectorresult.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case tcpdetectorresult.FieldAddrs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	case tcpdetectorresult.FieldResults:
		v, ok := value.(schema.TCPDetectorSubResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TCPDetectorResultMutation) AddedFields() []string {
	var fields []string
	if m.addtask != nil {
		fields = append(fields, tcpdetectorresult.FieldTask)
	}
	if m.addresult != nil {
		fields = append(fields, tcpdetectorresult.FieldResult)
	}
	if m.addmaxDuration != nil {
		fields = append(fields, tcpdetectorresult.FieldMaxDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TCPDetectorResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tcpdetectorresult.FieldTask:
		return m.AddedTask()
	case tcpdetectorresult.FieldResult:
		return m.AddedResult()
	case tcpdetectorresult.FieldMaxDuration:
		return m.AddedMaxDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TCPDetectorResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tcpdetectorresult.FieldTask:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTask(v)
		return nil
	case tcpdetectorresult.FieldResult:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDuration(v)
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TCPDetectorResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TCPDetectorResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TCPDetectorResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TCPDetectorResultMutation) ResetField(name string) error {
	switch name {
	case tcpdetectorresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tcpdetectorresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tcpdetectorresult.FieldTask:
		m.ResetTask()
		return nil
	case tcpdetectorresult.FieldResult:
		m.ResetResult()
		return nil
	case tcpdetectorresult.FieldMaxDuration:
		m.ResetMaxDuration()
		return nil
	case tcpdetectorresult.FieldMessages:
		m.ResetMessages()
		return nil
	case tcpdetectorresult.FieldAddrs:
		m.ResetAddrs()
		return nil
	case tcpdetectorresult.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown TCPDetectorResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TCPDetectorResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TCPDetectorResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TCPDetectorResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TCPDetectorResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TCPDetectorResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TCPDetectorResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TCPDetectorResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TCPDetectorResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TCPDetectorResult edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	status        *schema.Status
	addstatus     *schema.Status
	account       *string
	password      *string
	name          *string
	roles         *[]string
	groups        *[]string
	email         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s schema.Status) {
	m.status = &s
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds s to the "status" field.
func (m *UserMutation) AddStatus(s schema.Status) {
	if m.addstatus != nil {
		*m.addstatus += s
	} else {
		m.addstatus = &s
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r schema.Status, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAccount sets the "account" field.
func (m *UserMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetRoles sets the "roles" field.
func (m *UserMutation) SetRoles(s []string) {
	m.roles = &s
}

// Roles returns the value of the "roles" field in the mutation.
func (m *UserMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// ClearRoles clears the value of the "roles" field.
func (m *UserMutation) ClearRoles() {
	m.roles = nil
	m.clearedFields[user.FieldRoles] = struct{}{}
}

// RolesCleared returns if the "roles" field was cleared in this mutation.
func (m *UserMutation) RolesCleared() bool {
	_, ok := m.clearedFields[user.FieldRoles]
	return ok
}

// ResetRoles resets all changes to the "roles" field.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	delete(m.clearedFields, user.FieldRoles)
}

// SetGroups sets the "groups" field.
func (m *UserMutation) SetGroups(s []string) {
	m.groups = &s
}

// Groups returns the value of the "groups" field in the mutation.
func (m *UserMutation) Groups() (r []string, exists bool) {
	v := m.groups
	if v == nil {
		return
	}
	return *v, true
}

// OldGroups returns the old "groups" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroups: %w", err)
	}
	return oldValue.Groups, nil
}

// ClearGroups clears the value of the "groups" field.
func (m *UserMutation) ClearGroups() {
	m.groups = nil
	m.clearedFields[user.FieldGroups] = struct{}{}
}

// GroupsCleared returns if the "groups" field was cleared in this mutation.
func (m *UserMutation) GroupsCleared() bool {
	_, ok := m.clearedFields[user.FieldGroups]
	return ok
}

// ResetGroups resets all changes to the "groups" field.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	delete(m.clearedFields, user.FieldGroups)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.account != nil {
		fields = append(fields, user.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.roles != nil {
		fields = append(fields, user.FieldRoles)
	}
	if m.groups != nil {
		fields = append(fields, user.FieldGroups)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldAccount:
		return m.Account()
	case user.FieldPassword:
		return m.Password()
	case user.FieldName:
		return m.Name()
	case user.FieldRoles:
		return m.Roles()
	case user.FieldGroups:
		return m.Groups()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldAccount:
		return m.OldAccount(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldRoles:
		return m.OldRoles(ctx)
	case user.FieldGroups:
		return m.OldGroups(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	case user.FieldGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroups(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldRoles) {
		fields = append(fields, user.FieldRoles)
	}
	if m.FieldCleared(user.FieldGroups) {
		fields = append(fields, user.FieldGroups)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldRoles:
		m.ClearRoles()
		return nil
	case user.FieldGroups:
		m.ClearGroups()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldAccount:
		m.ResetAccount()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldRoles:
		m.ResetRoles()
		return nil
	case user.FieldGroups:
		m.ResetGroups()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserLoginMutation represents an operation that mutates the UserLogin nodes in the graph.
type UserLoginMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	account         *string
	user_agent      *string
	ip              *string
	track_id        *string
	session_id      *string
	x_forwarded_for *string
	country         *string
	province        *string
	city            *string
	isp             *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UserLogin, error)
	predicates      []predicate.UserLogin
}

var _ ent.Mutation = (*UserLoginMutation)(nil)

// userloginOption allows management of the mutation configuration using functional options.
type userloginOption func(*UserLoginMutation)

// newUserLoginMutation creates new mutation for the UserLogin entity.
func newUserLoginMutation(c config, op Op, opts ...userloginOption) *UserLoginMutation {
	m := &UserLoginMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginID sets the ID field of the mutation.
func withUserLoginID(id int) userloginOption {
	return func(m *UserLoginMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLogin
		)
		m.oldValue = func(ctx context.Context) (*UserLogin, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLogin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLogin sets the old UserLogin of the mutation.
func withUserLogin(node *UserLogin) userloginOption {
	return func(m *UserLoginMutation) {
		m.oldValue = func(context.Context) (*UserLogin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserLoginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAccount sets the "account" field.
func (m *UserLoginMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserLoginMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserLoginMutation) ResetAccount() {
	m.account = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *UserLoginMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserLoginMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserLoginMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[userlogin.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserLoginMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserLoginMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, userlogin.FieldUserAgent)
}

// SetIP sets the "ip" field.
func (m *UserLoginMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserLoginMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *UserLoginMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[userlogin.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *UserLoginMutation) IPCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *UserLoginMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, userlogin.FieldIP)
}

// SetTrackID sets the "track_id" field.
func (m *UserLoginMutation) SetTrackID(s string) {
	m.track_id = &s
}

// TrackID returns the value of the "track_id" field in the mutation.
func (m *UserLoginMutation) TrackID() (r string, exists bool) {
	v := m.track_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackID returns the old "track_id" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldTrackID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrackID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackID: %w", err)
	}
	return oldValue.TrackID, nil
}

// ClearTrackID clears the value of the "track_id" field.
func (m *UserLoginMutation) ClearTrackID() {
	m.track_id = nil
	m.clearedFields[userlogin.FieldTrackID] = struct{}{}
}

// TrackIDCleared returns if the "track_id" field was cleared in this mutation.
func (m *UserLoginMutation) TrackIDCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldTrackID]
	return ok
}

// ResetTrackID resets all changes to the "track_id" field.
func (m *UserLoginMutation) ResetTrackID() {
	m.track_id = nil
	delete(m.clearedFields, userlogin.FieldTrackID)
}

// SetSessionID sets the "session_id" field.
func (m *UserLoginMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *UserLoginMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *UserLoginMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[userlogin.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *UserLoginMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *UserLoginMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, userlogin.FieldSessionID)
}

// SetXForwardedFor sets the "x_forwarded_for" field.
func (m *UserLoginMutation) SetXForwardedFor(s string) {
	m.x_forwarded_for = &s
}

// XForwardedFor returns the value of the "x_forwarded_for" field in the mutation.
func (m *UserLoginMutation) XForwardedFor() (r string, exists bool) {
	v := m.x_forwarded_for
	if v == nil {
		return
	}
	return *v, true
}

// OldXForwardedFor returns the old "x_forwarded_for" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldXForwardedFor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldXForwardedFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldXForwardedFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXForwardedFor: %w", err)
	}
	return oldValue.XForwardedFor, nil
}

// ClearXForwardedFor clears the value of the "x_forwarded_for" field.
func (m *UserLoginMutation) ClearXForwardedFor() {
	m.x_forwarded_for = nil
	m.clearedFields[userlogin.FieldXForwardedFor] = struct{}{}
}

// XForwardedForCleared returns if the "x_forwarded_for" field was cleared in this mutation.
func (m *UserLoginMutation) XForwardedForCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldXForwardedFor]
	return ok
}

// ResetXForwardedFor resets all changes to the "x_forwarded_for" field.
func (m *UserLoginMutation) ResetXForwardedFor() {
	m.x_forwarded_for = nil
	delete(m.clearedFields, userlogin.FieldXForwardedFor)
}

// SetCountry sets the "country" field.
func (m *UserLoginMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserLoginMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *UserLoginMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[userlogin.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *UserLoginMutation) CountryCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *UserLoginMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, userlogin.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *UserLoginMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserLoginMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *UserLoginMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[userlogin.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *UserLoginMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *UserLoginMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, userlogin.FieldProvince)
}

// SetCity sets the "city" field.
func (m *UserLoginMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLoginMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *UserLoginMutation) ClearCity() {
	m.city = nil
	m.clearedFields[userlogin.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *UserLoginMutation) CityCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *UserLoginMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, userlogin.FieldCity)
}

// SetIsp sets the "isp" field.
func (m *UserLoginMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *UserLoginMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *UserLoginMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[userlogin.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *UserLoginMutation) IspCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *UserLoginMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, userlogin.FieldIsp)
}

// Op returns the operation name.
func (m *UserLoginMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLogin).
func (m *UserLoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, userlogin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userlogin.FieldUpdatedAt)
	}
	if m.account != nil {
		fields = append(fields, userlogin.FieldAccount)
	}
	if m.user_agent != nil {
		fields = append(fields, userlogin.FieldUserAgent)
	}
	if m.ip != nil {
		fields = append(fields, userlogin.FieldIP)
	}
	if m.track_id != nil {
		fields = append(fields, userlogin.FieldTrackID)
	}
	if m.session_id != nil {
		fields = append(fields, userlogin.FieldSessionID)
	}
	if m.x_forwarded_for != nil {
		fields = append(fields, userlogin.FieldXForwardedFor)
	}
	if m.country != nil {
		fields = append(fields, userlogin.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, userlogin.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, userlogin.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, userlogin.FieldIsp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlogin.FieldCreatedAt:
		return m.CreatedAt()
	case userlogin.FieldUpdatedAt:
		return m.UpdatedAt()
	case userlogin.FieldAccount:
		return m.Account()
	case userlogin.FieldUserAgent:
		return m.UserAgent()
	case userlogin.FieldIP:
		return m.IP()
	case userlogin.FieldTrackID:
		return m.TrackID()
	case userlogin.FieldSessionID:
		return m.SessionID()
	case userlogin.FieldXForwardedFor:
		return m.XForwardedFor()
	case userlogin.FieldCountry:
		return m.Country()
	case userlogin.FieldProvince:
		return m.Province()
	case userlogin.FieldCity:
		return m.City()
	case userlogin.FieldIsp:
		return m.Isp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlogin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userlogin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userlogin.FieldAccount:
		return m.OldAccount(ctx)
	case userlogin.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case userlogin.FieldIP:
		return m.OldIP(ctx)
	case userlogin.FieldTrackID:
		return m.OldTrackID(ctx)
	case userlogin.FieldSessionID:
		return m.OldSessionID(ctx)
	case userlogin.FieldXForwardedFor:
		return m.OldXForwardedFor(ctx)
	case userlogin.FieldCountry:
		return m.OldCountry(ctx)
	case userlogin.FieldProvince:
		return m.OldProvince(ctx)
	case userlogin.FieldCity:
		return m.OldCity(ctx)
	case userlogin.FieldIsp:
		return m.OldIsp(ctx)
	}
	return nil, fmt.Errorf("unknown UserLogin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlogin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userlogin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userlogin.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case userlogin.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case userlogin.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case userlogin.FieldTrackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackID(v)
		return nil
	case userlogin.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case userlogin.FieldXForwardedFor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXForwardedFor(v)
		return nil
	case userlogin.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case userlogin.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userlogin.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userlogin.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLogin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userlogin.FieldUserAgent) {
		fields = append(fields, userlogin.FieldUserAgent)
	}
	if m.FieldCleared(userlogin.FieldIP) {
		fields = append(fields, userlogin.FieldIP)
	}
	if m.FieldCleared(userlogin.FieldTrackID) {
		fields = append(fields, userlogin.FieldTrackID)
	}
	if m.FieldCleared(userlogin.FieldSessionID) {
		fields = append(fields, userlogin.FieldSessionID)
	}
	if m.FieldCleared(userlogin.FieldXForwardedFor) {
		fields = append(fields, userlogin.FieldXForwardedFor)
	}
	if m.FieldCleared(userlogin.FieldCountry) {
		fields = append(fields, userlogin.FieldCountry)
	}
	if m.FieldCleared(userlogin.FieldProvince) {
		fields = append(fields, userlogin.FieldProvince)
	}
	if m.FieldCleared(userlogin.FieldCity) {
		fields = append(fields, userlogin.FieldCity)
	}
	if m.FieldCleared(userlogin.FieldIsp) {
		fields = append(fields, userlogin.FieldIsp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginMutation) ClearField(name string) error {
	switch name {
	case userlogin.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case userlogin.FieldIP:
		m.ClearIP()
		return nil
	case userlogin.FieldTrackID:
		m.ClearTrackID()
		return nil
	case userlogin.FieldSessionID:
		m.ClearSessionID()
		return nil
	case userlogin.FieldXForwardedFor:
		m.ClearXForwardedFor()
		return nil
	case userlogin.FieldCountry:
		m.ClearCountry()
		return nil
	case userlogin.FieldProvince:
		m.ClearProvince()
		return nil
	case userlogin.FieldCity:
		m.ClearCity()
		return nil
	case userlogin.FieldIsp:
		m.ClearIsp()
		return nil
	}
	return fmt.Errorf("unknown UserLogin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginMutation) ResetField(name string) error {
	switch name {
	case userlogin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userlogin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userlogin.FieldAccount:
		m.ResetAccount()
		return nil
	case userlogin.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case userlogin.FieldIP:
		m.ResetIP()
		return nil
	case userlogin.FieldTrackID:
		m.ResetTrackID()
		return nil
	case userlogin.FieldSessionID:
		m.ResetSessionID()
		return nil
	case userlogin.FieldXForwardedFor:
		m.ResetXForwardedFor()
		return nil
	case userlogin.FieldCountry:
		m.ResetCountry()
		return nil
	case userlogin.FieldProvince:
		m.ResetProvince()
		return nil
	case userlogin.FieldCity:
		m.ResetCity()
		return nil
	case userlogin.FieldIsp:
		m.ResetIsp()
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserLogin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserLogin edge %s", name)
}
